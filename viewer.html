< !DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Commercial Manga Viewer</title><style> :root {
    --primary-color: #4a6cf7;
    --secondary-color: #ff6b6b;
    /* Simplified: Defaulting to light theme variables */
    --background-color: #ffffff;
    --text-color: #333333;
    --overlay-background: rgba(0, 0, 0, 0.7);
    --overlay-text: #ffffff;
    --button-background: rgba(255, 255, 255, 0.2);
    --button-hover: rgba(255, 255, 255, 0.4);
    --slider-track: rgba(255, 255, 255, 0.3);
    --slider-thumb: #ffffff;
    --spinner-color: #ffffff;
    --error-color: #ff4d4d;
}

/* Optional: Keep dark theme styles if system preference detection is desired, */
/* but remove the manual switching buttons/logic */
@media (prefers-color-scheme: dark) {
    :root {
        --background-color: #121212;
        --text-color: #f1f1f1;
        --overlay-background: rgba(0, 0, 0, 0.8);
    }
}


* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-color: var(--background-color);
    color: var(--text-color);
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    position: fixed;
    touch-action: manipulation;
    /* Avoids zoom on double tap, etc. */
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

#viewer-container {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    background-color: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: grab;
}

#viewer-container:active {
    cursor: grabbing;
}

#zoom-container {
    width: 100%;
    height: 100%;
    position: absolute;
    display: flex;
    justify-content: center;
    align-items: center;
    transform-origin: center;
    /* 動的な変更時のみトランジションを適用する（JSで制御） */
    transition: none;
    /* ハードウェアアクセラレーションを有効化 */
    transform: translate3d(0, 0, 0);
    will-change: transform;
}

#manga-page-container {
    position: relative;
    height: 100%;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

.manga-page {
    display: block;
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    /* Default fit mode */
    transform-origin: center;
    transition: opacity 0.3s ease;
    pointer-events: none;
    flex-shrink: 0;
    background-color: transparent;
    /* Use transparent bg by default */
    /* ハードウェアアクセラレーションを有効化 */
    transform: translateZ(0);
    will-change: transform, opacity;
}

/* Navigation zones */
.nav-zone {
    position: absolute;
    height: 100%;
    width: 30%;
    top: 0;
    z-index: 10;
    /* background-color: rgba(255,0,0,0.1); */
    /* For debugging */
}

#prev-zone {
    left: 0;
    cursor: pointer;
}

#next-zone {
    right: 0;
    cursor: pointer;
}

#center-zone {
    left: 30%;
    width: 40%;
    cursor: pointer;
    /* background-color: rgba(0,255,0,0.1); */
    /* For debugging */
}

/* UI Overlays */
.ui-overlay {
    position: absolute;
    left: 0;
    width: 100%;
    padding: 15px;
    color: var(--overlay-text);
    background-color: var(--overlay-background);
    z-index: 20;
    transition: transform 0.3s ease, opacity 0.3s ease;
    display: flex;
    justify-content: space-between;
    align-items: center;
    pointer-events: none;
    /* ハードウェアアクセラレーションを有効化 */
    transform: translate3d(0, 0, 0);
    will-change: transform, opacity;
    opacity: 0;
    /* Start hidden */
}

.ui-overlay>* {
    pointer-events: auto;
}

#top-overlay {
    top: 0;
    transform: translateY(-100%);
}

#bottom-overlay {
    bottom: 0;
    transform: translateY(100%);
}

#viewer-container.show-ui .ui-overlay {
    /* Target overlays inside show-ui container */
    transform: translateY(0);
    opacity: 1;
}

/* Buttons and controls */
.ui-button {
    background-color: var(--button-background);
    border: none;
    color: var(--overlay-text);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.2s ease;
    flex-shrink: 0;
    padding: 0;
    /* Ensure no extra padding */
}

.ui-button:hover,
.ui-button:active {
    background-color: var(--button-hover);
}

.ui-button:disabled {
    opacity: 0.5;
    cursor: default;
    background-color: var(--button-background);
    /* Prevent hover effect */
}


.ui-button svg {
    width: 24px;
    height: 24px;
    fill: currentColor;
}

/* Page slider */
#page-slider-container {
    flex-grow: 1;
    margin: 0 15px;
    display: flex;
    align-items: center;
}

#page-slider {
    width: 100%;
    height: 8px;
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    background: var(--slider-track);
    border-radius: 4px;
    outline: none;
}

#page-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--slider-thumb);
    cursor: pointer;
}

#page-slider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--slider-thumb);
    cursor: pointer;
    border: none;
}

/* Loading spinner */
#loading-spinner {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 50px;
    height: 50px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: var(--spinner-color);
    animation: spin 1s ease-in-out infinite;
    z-index: 40;
    display: none;
    /* Initially hidden */
    transform: translate(-50%, -50%);
    /* Ensure centering */
}

@keyframes spin {
    from {
        transform: translate(-50%, -50%) rotate(0deg);
    }

    to {
        transform: translate(-50%, -50%) rotate(360deg);
    }
}

/* Error message */
#error-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: var(--error-color);
    color: white;
    padding: 15px 20px;
    border-radius: 5px;
    max-width: 80%;
    text-align: center;
    z-index: 40;
    display: none;
    /* Initially hidden */
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

#retry-button {
    margin-top: 15px;
    padding: 8px 15px;
    background-color: white;
    color: var(--error-color);
    border: none;
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease;
}

#retry-button:hover {
    background-color: #eee;
}

/* Episode Overlay */
#episode-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--overlay-background);
    z-index: 50;
    display: none;
    /* Changed from flex to none */
    justify-content: center;
    align-items: center;
    opacity: 0;
    /* Add opacity for transition */
    transition: opacity 0.3s ease;
    pointer-events: none;
}

#episode-overlay.active {
    display: flex;
    opacity: 1;
    pointer-events: auto;
}

.modal-content {
    width: 80%;
    max-width: 500px;
    background-color: var(--background-color);
    color: var(--text-color);
    /* Ensure text color contrasts */
    border-radius: 8px;
    padding: 20px;
    max-height: 80vh;
    overflow-y: auto;
    transform: scale(0.95);
    /* Add subtle scale effect */
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

#episode-overlay.active .modal-content {
    transform: scale(1);
    opacity: 1;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    border-bottom: 1px solid rgba(128, 128, 128, 0.2);
    /* Add separator */
    padding-bottom: 10px;
}

.modal-header h2 {
    margin: 0;
    /* Remove default margin */
}


#episode-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.episode-item {
    padding: 12px;
    background-color: rgba(128, 128, 128, 0.1);
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.episode-item:hover {
    background-color: rgba(128, 128, 128, 0.2);
}

.episode-item.current {
    border-left: 3px solid var(--primary-color);
    font-weight: bold;
    background-color: rgba(128, 128, 128, 0.15);
    /* Slightly different background */
}

#close-episode-btn {
    /* Style close button */
    background: none;
    border: none;
    font-size: 24px;
    line-height: 1;
    color: var(--text-color);
    opacity: 0.7;
    width: auto;
    /* Override default button size */
    height: auto;
}

#close-episode-btn:hover {
    opacity: 1;
    background: none;
    /* Override hover */
}

</style></head><body>< !-- Start with UI hidden,
show after load --><div id="viewer-container">< !-- Zoom container --><div id="zoom-container">< !-- Manga page container (Simplified: Only one page element needed) --><div id="manga-page-container">< !-- Set initial src to avoid broken image,
or use placeholder --><img alt="Manga page" class="manga-page" id="current-page" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">< !-- Transparent 1x1 GIF --></div></div>< !-- Navigation zones --><div class="nav-zone" id="prev-zone" aria-label="Previous Page"></div><div class="nav-zone" id="center-zone" aria-label="Toggle UI"></div><div class="nav-zone" id="next-zone" aria-label="Next Page"></div>< !-- Top UI overlay --><div class="ui-overlay" id="top-overlay"><div id="content-title">Loading...</div><div id="page-number">- / - </div></div>< !-- Bottom UI overlay --><div class="ui-overlay" id="bottom-overlay"><button class="ui-button" id="prev-button" aria-label="Previous Page" disabled>< !-- Start disabled --><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M15.41,16.59L10.83,12l4.58-4.59L14,6l-6,6l6,6L15.41,16.59z"></path></svg></button><div id="page-slider-container"><input type="range" min="1" max="1" value="1" id="page-slider" aria-label="Page Slider" disabled>< !-- Start disabled --></div><button class="ui-button" id="next-button" aria-label="Next Page" disabled>< !-- Start disabled --><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8.59,16.59L13.17,12L8.59,7.41L10,6l6,6l-6,6L8.59,16.59z"></path></svg></button><button class="ui-button" id="fullscreen-button" aria-label="Toggle Fullscreen"><svg viewBox="0 0 24 24" aria-hidden="true"><path id="fullscreen-enter-icon"
d="M7,14H5v5h5v-2H7V14z M5,10h2V7h3V5H5V10z M17,17h-3v2h5v-5h-2V17z M14,5v2h3v3h2V5H14z"></path><path id="fullscreen-exit-icon"
d="M5,16h3v3h2v-5H5V16z M8,5H5v5h2V7h3V5z M14,19h2v-3h3v-2h-5V19z M16,8h3V5h-2v3h-3V8z"
style="display: none;"></path></svg></button><div id="episode-navigation"><button class="ui-button" id="episode-btn" aria-label="エピソード選択" disabled>< !-- Start disabled --><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3,13h2v-2H3V13z M3,17h2v-2H3V17z M3,9h2V7H3V9z M7,13h14v-2H7V13z M7,17h14v-2H7V17z M7,7v2h14V7H7z"></path></svg></button></div></div>< !-- Episode Selection Modal --><div id="episode-overlay" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="episode-modal-title"><div class="modal-content"><div class="modal-header"><h2 id="episode-modal-title">エピソード選択</h2><button id="close-episode-btn" class="ui-button" aria-label="閉じる">×</button></div><div id="episode-list">< !-- Episode items will be populated here --></div></div></div>< !-- Loading spinner --><div id="loading-spinner" aria-label="Loading" role="status"></div>< !-- Error message --><div id="error-message" role="alert"><div id="error-text">読み込みに失敗しました。</div><button id="retry-button">再試行</button></div></div><script> // --- 定数の定義 ---
const UI_HIDE_DELAY_MS=3000;
const DOUBLE_TAP_TIMEOUT_MS=300;
const SWIPE_THRESHOLD_PX=50;
const SWIPE_VERTICAL_THRESHOLD_PX=75;
const MAX_ZOOM_SCALE=5;
const DOUBLE_TAP_ZOOM_SCALE=2;
const PRELOAD_DEPTH=2;
const MIN_TAP_DURATION_MS=50; // ダブルタップ判定時の最小タップ時間

// Main viewer class
class MangaViewer {
    constructor() {
        // 定数をプロパティとして設定
        this.UI_HIDE_DELAY_MS=UI_HIDE_DELAY_MS;
        this.DOUBLE_TAP_TIMEOUT_MS=DOUBLE_TAP_TIMEOUT_MS;
        this.SWIPE_THRESHOLD_PX=SWIPE_THRESHOLD_PX;
        this.SWIPE_VERTICAL_THRESHOLD_PX=SWIPE_VERTICAL_THRESHOLD_PX;
        this.MAX_ZOOM_SCALE=MAX_ZOOM_SCALE;
        this.DOUBLE_TAP_ZOOM_SCALE=DOUBLE_TAP_ZOOM_SCALE;
        this.PRELOAD_DEPTH=PRELOAD_DEPTH;
        this.MIN_TAP_DURATION_MS=MIN_TAP_DURATION_MS;

        // DOM elements - getElementでエラーチェックを行う
        try {
            this.viewerContainer=this.getElement('viewer-container');
            this.zoomContainer=this.getElement('zoom-container');
            this.pageContainer=this.getElement('manga-page-container');
            this.currentPage=this.getElement('current-page');
            this.topOverlay=this.getElement('top-overlay');
            this.bottomOverlay=this.getElement('bottom-overlay');
            this.pageSlider=this.getElement('page-slider');
            this.pageNumber=this.getElement('page-number');
            this.contentTitle=this.getElement('content-title');
            this.loadingSpinner=this.getElement('loading-spinner');
            this.errorMessage=this.getElement('error-message');
            this.errorText=this.getElement('error-text');
            this.retryButton=this.getElement('retry-button');
            this.episodeOverlay=this.getElement('episode-overlay');
            this.episodeList=this.getElement('episode-list');
            this.closeEpisodeButton=this.getElement('close-episode-btn');
            this.prevZone=this.getElement('prev-zone');
            this.nextZone=this.getElement('next-zone');
            this.centerZone=this.getElement('center-zone');
            this.prevButton=this.getElement('prev-button');
            this.nextButton=this.getElement('next-button');
            this.fullscreenButton=this.getElement('fullscreen-button');
            this.fullscreenEnterIcon=this.getElement('fullscreen-enter-icon');
            this.fullscreenExitIcon=this.getElement('fullscreen-exit-icon');
            this.episodeButton=this.getElement('episode-btn');
        }

        catch (error) {
            console.error("初期化エラー:", error);

            // エラーメッセージを表示する試み（ただし、errorMessage要素自体がない可能性もある）
            try {
                const errorDiv=document.getElementById('error-message') || document.createElement('div');
                errorDiv.id='init-error-fallback'; // Avoid conflict if error-message exists but is broken

                errorDiv.textContent=`ビューアの初期化に失敗しました: $ {
                    error.message
                }

                。ページをリロードしてください。`;
                errorDiv.style.display='block';
                errorDiv.style.position='fixed';
                errorDiv.style.top='50%';
                errorDiv.style.left='50%';
                errorDiv.style.transform='translate(-50%, -50%)';
                errorDiv.style.backgroundColor='var(--error-color, #ff4d4d)'; // Use CSS var if available
                errorDiv.style.color='white';
                errorDiv.style.padding='20px';
                errorDiv.style.borderRadius='5px';
                errorDiv.style.zIndex='1000';
                errorDiv.style.textAlign='center';

                if ( !document.getElementById(errorDiv.id)) {
                    document.body.appendChild(errorDiv);
                }
            }

            catch (displayError) {
                console.error("フォールバックエラー表示失敗:", displayError);
            }

            return; // Stop initialization
        }

        // State variables
        this.currentPageIndex=0;
        this.totalPages=0;
        this.allPages=[];
        this.episodeStructure=[];
        this.mangaData=null;
        this.readingDirection='rtl'; // Default
        this.isUIVisible=false;
        this.uiHideTimeout=null;
        this.isLoading=false;
        this.isInitialized=false;
        this.touchStartX=0;
        this.touchStartY=0;
        this.panStartX=0;
        this.panStartY=0;
        this.lastTapTime=0;
        this.scale=1;
        this.translateX=0;
        this.translateY=0;
        this.initialDistance=0;
        this.isZooming=false;
        this.isPanning=false;
        this.pinchCenterX=0;
        this.pinchCenterY=0;
        this.initialScale=1;
        this.activePointers=new Map();

        // --- Mock Manga Data --- (Keep for standalone testing)
        this.mockMangaData= {

            id: 'manga123',
            title: 'KARMA',
            frontMatter: [ {
                page_number: 1, image_url: 'i_001.jpg', type: 'cover'
            }

            ,
            {
            page_number: 2, image_url: 'i_002.jpg', type: 'contents'
        }

        ],
        episodes: [ {

            id: 'episode1',
            title: '第1話',
            pages: [ {
                page_number: 3, image_url: 'i_003.jpg'
            }

            ,
            {
            page_number: 4, image_url: 'i_004.jpg'
        }

        ,
        {
        page_number: 5, image_url: 'i_005.jpg'
    }

    ,
    {
    page_number: 6, image_url: 'i_006.jpg'
}

,
{
page_number: 7, image_url: 'i_007.jpg'
}

,
{
page_number: 8, image_url: 'i_008.jpg'
}

,
{
page_number: 9, image_url: 'i_009.jpg'
}

,
{
page_number: 10, image_url: 'i_010.jpg'
}

,
{
page_number: 11, image_url: 'i_011.jpg'
}

,
{
page_number: 12, image_url: 'i_012.jpg'
}

,
{
page_number: 13, image_url: 'i_013.jpg'
}

]
}

,
{

id: 'episode2',
title: '第2話',
pages: [ {
    page_number: 14, image_url: 'i_014.jpg'
}

,
{
page_number: 15, image_url: 'i_015.jpg'
}

,
{
page_number: 16, image_url: 'i_016.jpg'
}

,
{
page_number: 17, image_url: 'i_017.jpg'
}

,
{
page_number: 18, image_url: 'i_018.jpg'
}

,
{
page_number: 19, image_url: 'i_019.jpg'
}

,
{
page_number: 20, image_url: 'i_020.jpg'
}

,
{
page_number: 21, image_url: 'i_021.jpg'
}

,
{
page_number: 22, image_url: 'i_022.jpg'
}

]
}

,
{

id: 'episode3',
title: '第3話',
pages: [ {
    page_number: 23, image_url: 'i_023.jpg'
}

,
{
page_number: 24, image_url: 'i_024.jpg'
}

,
{
page_number: 25, image_url: 'i_025.jpg'
}

,
{
page_number: 26, image_url: 'i_026.jpg'
}

,
{
page_number: 27, image_url: 'i_027.jpg'
}

,
{
page_number: 28, image_url: 'i_028.jpg'
}

,
{
page_number: 29, image_url: 'i_029.jpg'
}

,
{
page_number: 30, image_url: 'i_030.jpg'
}

,
{
page_number: 31, image_url: 'i_031.jpg'
}

]
}

,
{

id: 'episode4',
title: '第4話',
pages: [ {
    page_number: 32, image_url: 'i_032.jpg'
}

,
{
page_number: 33, image_url: 'i_033.jpg'
}

,
{
page_number: 34, image_url: 'i_034.jpg'
}

,
{
page_number: 35, image_url: 'i_035.jpg'
}

,
{
page_number: 36, image_url: 'i_036.jpg'
}

,
{
page_number: 37, image_url: 'i_037.jpg'
}

,
{
page_number: 38, image_url: 'i_038.jpg'
}

,
{
page_number: 39, image_url: 'i_039.jpg'
}

,
{
page_number: 40, image_url: 'i_040.jpg'
}

]
}

,
{

id: 'episode5',
title: '第5話',
pages: [ {
    page_number: 41, image_url: 'i_041.jpg'
}

,
{
page_number: 42, image_url: 'i_042.jpg'
}

,
{
page_number: 43, image_url: 'i_043.jpg'
}

,
{
page_number: 44, image_url: 'i_044.jpg'
}

,
{
page_number: 45, image_url: 'i_045.jpg'
}

,
{
page_number: 46, image_url: 'i_046.jpg'
}

,
{
page_number: 47, image_url: 'i_047.jpg'
}

,
{
page_number: 48, image_url: 'i_048.jpg'
}

]
}

],
reading_direction: 'rtl' // Can be 'rtl' or 'ltr'
}

;
// --- End Mock Data ---

// init() is called from the DOMContentLoaded listener
}

getElement(id) {
    const element=document.getElementById(id);

    if ( !element) {

        // Throw an error for missing required elements
        throw new Error(`Required DOM element not found (ID: $ {
                    id
                })`);
    }

    return element;
}

async init() {
    // Prevent double initialization
    if (this.isInitialized) return;

    console.log("Viewer initialization started...");
    this.setupEventListeners();
    this.resetZoom();
    this.updateFullscreenIcon();

    try {
        // Wait for manga data to load and process
        await this.loadMangaData();
        // isInitialized is set within loadMangaData on success
        console.log("Viewer initialization completed.");
    }

    catch (error) {
        console.error("Initialization failed:", error);
        // Error is shown by loadMangaData or constructor fallback
        // UI controls are disabled within loadMangaData on failure
    }
}

setupEventListeners() {

    // Use event delegation where possible
    this.bottomOverlay.addEventListener('click', (e)=> {
            if ( !this.isInitialized) return; // Prevent actions before init
            const target=e.target.closest('.ui-button');
            if ( !target || target.disabled) return;

            // Use nextPage/prevPage which handle RTL logic
            if (target.id==='prev-button') this.prevPage();
            else if (target.id==='next-button') this.nextPage();
            else if (target.id==='fullscreen-button') this.toggleFullscreen();
            else if (target.id==='episode-btn') this.showEpisodeList();
        });

    // Navigation zones (Click/Tap) - Use nextPage/prevPage
    this.prevZone.addEventListener('click', (e)=> {
            if (this.isInitialized) this.prevPage();
        });

    this.nextZone.addEventListener('click', (e)=> {
            if (this.isInitialized) this.nextPage();
        });

    this.centerZone.addEventListener('click', (e)=> {
            if (this.isInitialized) this.toggleUI();
        });


    // Slider
    this.pageSlider.addEventListener('input', this.onSliderInput.bind(this));
    this.pageSlider.addEventListener('change', this.onSliderChange.bind(this));

    // Retry button
    this.retryButton.addEventListener('click', this.retryLoad.bind(this));

    // Episode modal close button
    this.closeEpisodeButton.addEventListener('click', this.hideEpisodeList.bind(this));

    // Close modal if clicking outside the content
    this.episodeOverlay.addEventListener('click', (e)=> {
            if (e.target===this.episodeOverlay) {
                // Clicked on the backdrop
                this.hideEpisodeList();
            }
        });


    // Pointer events for touch, mouse, pen
    this.viewerContainer.addEventListener('pointerdown', this.handlePointerDown.bind(this));

    this.viewerContainer.addEventListener('pointermove', this.handlePointerMove.bind(this), {
        passive: false
    }); // Need preventDefault
this.viewerContainer.addEventListener('pointerup', this.handlePointerEnd.bind(this));
this.viewerContainer.addEventListener('pointercancel', this.handlePointerCancel.bind(this)); // Handle interruptions

// Keyboard navigation
document.addEventListener('keydown', this.handleKeyDown.bind(this));

// Window resize event
window.addEventListener('resize', this.handleResize.bind(this));

// Fullscreen change event
document.addEventListener('fullscreenchange', this.updateFullscreenIcon.bind(this));
document.addEventListener('webkitfullscreenchange', this.updateFullscreenIcon.bind(this)); // Safari/iOS
}

async fetchMangaData() {
    // isLoading is set by the caller (loadMangaData)
    // this.isLoading = true; // Should be set before calling fetch
    this.loadingSpinner.style.display='block';
    this.errorMessage.style.display='none';
    console.log("Fetching manga data (simulated)...");

    return new Promise((resolve, reject)=> {
            setTimeout(()=> {
                    try {
                        // Simulate potential API error
                        // if (Math.random() > 0.8) throw new Error("Simulated network error");
                        console.log("Data fetched (simulated)");
                        resolve(this.mockMangaData); // Use mock data
                    }

                    catch (error) {
                        console.error("Error fetching manga data:", error);
                        reject(error);
                    }

                    finally {
                        // isLoading should be managed by the caller (loadMangaData)
                        // Spinner is managed by the caller
                    }
                }

                , 500); // Simulate network delay
        });
}

async loadMangaData() {
    if (this.isLoading) return;
    this.isLoading=true; // Set loading flag
    this.loadingSpinner.style.display='block';
    this.errorMessage.style.display='none';
    this.isInitialized=false; // Ensure not initialized until success

    try {
        const data=await this.fetchMangaData();
        this.mangaData=data;

        this.contentTitle.textContent=data.title || 'Manga Viewer';
        // Explicitly check for 'ltr', otherwise default to 'rtl'
        this.readingDirection=data.reading_direction==='ltr' ? 'ltr': 'rtl';
        console.log("Reading Direction set to:", this.readingDirection);

        // --- Process episodes and pages ---
        this.episodeStructure=[];
        let combinedPages=[];
        let pageCount=0;

        if (data.frontMatter && Array.isArray(data.frontMatter) && data.frontMatter.length > 0) {
            const fmStart=pageCount;
            const fmEnd=fmStart+data.frontMatter.length - 1;

            this.episodeStructure.push({
                id: 'frontmatter',
                title: '表紙・目次',
                startPage: fmStart,
                endPage: fmEnd,
                totalPages: data.frontMatter.length
            });

        combinedPages=combinedPages.concat(data.frontMatter.map((p, i)=> ({
                    ...p, index: fmStart + i
                }))); // Add index
    pageCount+=data.frontMatter.length;
}

if (data.episodes && Array.isArray(data.episodes) && data.episodes.length > 0) {
    data.episodes.forEach((episode, index)=> {
            if (episode.pages && Array.isArray(episode.pages) && episode.pages.length > 0) {
                const epStart=pageCount;
                const epEnd=epStart + episode.pages.length - 1;

                this.episodeStructure.push({
                    id: episode.id || `episode$ {
                        index + 1
                    }

                    `,
                    title: episode.title || `第$ {
                        index + 1
                    }

                    話`,
                    startPage: epStart,
                    endPage: epEnd,
                    totalPages: episode.pages.length
                });

            combinedPages=combinedPages.concat(episode.pages.map((p, i)=> ({
                        ...p, index: epStart + i
                    }))); // Add index
        pageCount +=episode.pages.length;
    }
});
}

// --- End Processing ---

this.allPages=combinedPages;
this.totalPages=this.allPages.length;

if (this.totalPages===0) {
    throw new Error("No pages available to display.");
}

// Enable UI controls
this.pageSlider.max=this.totalPages;
this.pageSlider.min=1;
this.pageSlider.disabled=false;
this.episodeButton.disabled=this.episodeStructure.length <=1; // Disable if only frontmatter or one episode


this.loadBookmark(); // Load bookmark BEFORE loading the first page

// Load the initial page (await this)
await this.loadPage(this.currentPageIndex);

this.isInitialized=true; // Set initialized flag ONLY on full success
this.loadingSpinner.style.display='none';
this.updatePageNumber(); // Update UI elements now that we are initialized
this.showUI(); // Show UI after initial load

}

catch (error) {
    console.error("Error processing manga data:", error);

    this.showError(`Failed to load or process data: $ {
            error.message
        }

        `);
    // Keep UI disabled
    this.pageSlider.disabled=true;
    this.episodeButton.disabled=true;
    this.isInitialized=false;
    // Re-throw the error to signal failure to init()
    throw error;
}

finally {
    // Ensure loading state is reset regardless of success or failure
    this.isLoading=false;
    this.loadingSpinner.style.display='none';
}
}

// --- UI Visibility ---
showUI(autoHide=true) {
    if ( !this.isInitialized) return;
    this.viewerContainer.classList.add('show-ui');
    this.isUIVisible=true;
    this.clearUiHideTimeout();

    if (autoHide) {
        this.scheduleUiHide();
    }
}

hideUI() {
    if (this.episodeOverlay.classList.contains('active')) return; // Don't hide if modal is open
    this.viewerContainer.classList.remove('show-ui');
    this.isUIVisible=false;
    this.clearUiHideTimeout();
}

toggleUI(forceShow=false) {
    if (forceShow) {
        this.showUI();
    }

    else if (this.isUIVisible) {
        this.hideUI();
    }

    else {
        this.showUI();
    }
}

scheduleUiHide() {
    this.clearUiHideTimeout();

    this.uiHideTimeout=setTimeout(()=> {
            this.hideUI();
        }

        , this.UI_HIDE_DELAY_MS); // Use constant
}

clearUiHideTimeout() {
    if (this.uiHideTimeout) {
        clearTimeout(this.uiHideTimeout);
        this.uiHideTimeout=null;
    }
}

// --- Episode List ---
showEpisodeList() {
    if ( !this.episodeStructure || this.episodeStructure.length===0 || !this.isInitialized) return;

    this.episodeList.innerHTML=''; // Clear previous items

    let currentEpisodeItem=null; // To focus later

    this.episodeStructure.forEach(episode=> {
            const episodeItem=document.createElement('div');
            episodeItem.className='episode-item';
            episodeItem.textContent=episode.title;
            episodeItem.dataset.startPage=episode.startPage; // Store start page index
            episodeItem.setAttribute('role', 'button');
            episodeItem.tabIndex=0; // Make it focusable

            // Highlight current episode
            if (this.currentPageIndex >=episode.startPage && this.currentPageIndex <=episode.endPage) {
                episodeItem.classList.add('current');
                episodeItem.setAttribute('aria-current', 'true');
                currentEpisodeItem=episodeItem; // Mark for focus
            }

            const selectEpisode=()=> {
                const targetPage=parseInt(episodeItem.dataset.startPage, 10);
                this.goToPage(targetPage);
                this.hideEpisodeList();
            }

            ;

            episodeItem.addEventListener('click', selectEpisode);

            episodeItem.addEventListener('keydown', (e)=> {
                    if (e.key==='Enter' || e.key===' ') {
                        e.preventDefault();
                        selectEpisode();
                    }
                });

            this.episodeList.appendChild(episodeItem);
        });

    this.episodeOverlay.classList.add('active');
    this.clearUiHideTimeout(); // Prevent UI from hiding

    // Focus management for accessibility
    requestAnimationFrame(()=> {

            // Ensure elements are rendered
            if (currentEpisodeItem) {
                currentEpisodeItem.focus();
            }

            else {
                this.closeEpisodeButton.focus();
            }
        });
}

hideEpisodeList() {
    this.episodeOverlay.classList.remove('active');
    this.scheduleUiHide(); // Resume auto-hide schedule
    // Optional: Return focus to the episode button?
    // this.episodeButton.focus();
}

// --- Fullscreen ---
toggleFullscreen() {
    if ( !document.fullscreenElement && !document.webkitFullscreenElement) {
        const element=document.documentElement;

        if (element.requestFullscreen) element.requestFullscreen().catch(err=> console.error(`Fullscreen request failed: $ {
                    err.message
                }

                `));
        else if (element.webkitRequestFullscreen) element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT); // Older Safari
    }

    else {
        if (document.exitFullscreen) document.exitFullscreen().catch(err=> console.error(`Exit Fullscreen failed: $ {
                    err.message
                }

                `));
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); // Older Safari
    }
}

updateFullscreenIcon() {
    const isFullscreen= ! !(document.fullscreenElement || document.webkitFullscreenElement);

    if (this.fullscreenEnterIcon && this.fullscreenExitIcon) {
        this.fullscreenEnterIcon.style.display=isFullscreen ? 'none': 'block';
        this.fullscreenExitIcon.style.display=isFullscreen ? 'block': 'none';
        this.fullscreenButton.setAttribute('aria-label', isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen');
    }
}

// --- Page Navigation (RTL Handled) ---
prevPage() {
    if ( !this.isInitialized || this.isLoading) return;
    // RTL: 前へ (Visually Right) -> 次のページ (index 増)
    // LTR: 前へ (Visually Left) -> 前のページ (index 減)
    const targetIndex=this.readingDirection==='rtl'
    ? this.currentPageIndex+1: this.currentPageIndex - 1;

    // Check boundaries before calling goToPage
    if (targetIndex >=0 && targetIndex < this.totalPages) {
        this.goToPage(targetIndex);
        this.showUI();
    }

    else {
        console.log("Already at the boundary (prevPage)");
        // Optionally provide visual feedback (e.g., slight shake)
    }
}

nextPage() {
    if ( !this.isInitialized || this.isLoading) return;
    // RTL: 次へ (Visually Left) -> 前のページ (index 減)
    // LTR: 次へ (Visually Right) -> 次のページ (index 増)
    const targetIndex=this.readingDirection==='rtl'
    ? this.currentPageIndex - 1: this.currentPageIndex + 1;

    // Check boundaries before calling goToPage
    if (targetIndex >=0 && targetIndex < this.totalPages) {
        this.goToPage(targetIndex);
        this.showUI();
    }

    else {
        console.log("Already at the boundary (nextPage)");
        // Optionally provide visual feedback
    }
}

goToPage(pageIndex) {
    // Clamp index just in case, though prev/nextPage should handle boundaries
    const newIndex=Math.max(0, Math.min(pageIndex, this.totalPages - 1));

    // Prevent unnecessary loading or navigation during load
    if ((newIndex===this.currentPageIndex && this.isInitialized && this.currentPage.dataset.imageUrl !=='error') || this.isLoading) {
        if (this.isLoading) console.log("Page load in progress, navigation skipped.");
        else console.log("Already on page", newIndex + 1);
        return;
    }

    console.log(`Navigating to page index $ {
            newIndex
        }

        (Page $ {
                newIndex + 1
            })`);
    this.currentPageIndex=newIndex;
    this.resetZoom();

    // Start loading, then update UI and save bookmark AFTER load attempt finishes
    this.loadPage(this.currentPageIndex) .then(()=> {
            console.log(`Page $ {
                    this.currentPageIndex + 1
                }

                load successful (or already loaded). Updating UI.`);

        }) .catch(err=> {

            // Error is handled in loadPage (showError), just log here
            console.warn(`goToPage: loadPage failed for index $ {
                    this.currentPageIndex
                }

                . Error: $ {
                    err.message
                }

                `);

        }) .finally(()=> {
            // Update UI elements and save bookmark regardless of load success/fail,
            // ensuring they reflect the *attempted* page index.
            this.updatePageNumber();
            this.saveBookmark();
        });

    this.showUI(); // Show UI briefly after initiating navigation
}

onSliderInput() {
    if ( !this.isInitialized) return;
    const sliderValue=parseInt(this.pageSlider.value, 10);

    // Update page number display instantly during slider drag
    this.pageNumber.textContent=`$ {
        sliderValue
    }

    / $ {
        this.totalPages
    }

    `;

    // Update ARIA value text during drag as well
    this.pageSlider.setAttribute('aria-valuetext', `Page $ {
            sliderValue
        }

        of $ {
            this.totalPages
        }

        `);
    this.showUI(false); // Show UI but don't restart auto-hide timer yet
    this.clearUiHideTimeout();
}

onSliderChange() {
    if ( !this.isInitialized) return;
    const targetPage=parseInt(this.pageSlider.value) - 1;
    this.goToPage(targetPage);
    this.scheduleUiHide(); // Restart auto-hide after slider release
}

retryLoad() {
    this.errorMessage.style.display='none';

    if (this.mangaData && this.isInitialized) {

        // Retry loading the current page index
        console.log(`Retrying load for page index $ {
                this.currentPageIndex
            }

            `);
        this.loadPage(this.currentPageIndex);
    }

    else {
        // Retry loading the initial manga data
        console.log("Retrying initial data load...");
        this.init().catch(err=> console.error("Retry initialization failed:", err)); // Re-run init
    }
}

// --- Bookmarking (Using localStorage) ---
saveBookmark() {

    // Only save if initialized and data is present
    if ( !this.mangaData || !this.mangaData.id || !this.allPages.length || !this.isInitialized) {
        // console.log("Skipping bookmark save (not ready).");
        return;
    }

    try {
        const key=`mangaViewer_$ {
            this.mangaData.id
        }

        _bookmark`;
        localStorage.setItem(key, this.currentPageIndex.toString());
        // console.log(`Bookmark saved: ${key} = ${this.currentPageIndex}`);
    }

    catch (error) {
        console.error('Error saving bookmark to localStorage:', error);
    }
}

loadBookmark() {

    // Requires mangaData to be loaded to get the ID
    if ( !this.mangaData || !this.mangaData.id || this.totalPages===0) {
        this.currentPageIndex=0; // Default to first page if no data or pages
        // console.log("Skipping bookmark load (no data/pages). Defaulting to index 0.");
        return;
    }

    ;

    try {
        const key=`mangaViewer_$ {
            this.mangaData.id
        }

        _bookmark`;
        const savedIndexStr=localStorage.getItem(key);

        if (savedIndexStr !==null) {
            const savedIndex=parseInt(savedIndexStr, 10);

            // Validate the loaded index
            if ( !isNaN(savedIndex) && savedIndex >=0 && savedIndex < this.totalPages) {
                console.log(`Bookmark loaded: $ {
                        key
                    }

                    =$ {
                        savedIndex
                    }

                    `);
                this.currentPageIndex=savedIndex;
                return; // Valid bookmark found
            }

            else {
                console.warn(`Invalid bookmark value found: $ {
                        savedIndexStr
                    }

                    . Removing.`);
                localStorage.removeItem(key); // Clean up invalid data
            }
        }

        else {
            // console.log(`No bookmark found for key: ${key}`);
        }

        // Default to first page if no valid bookmark found
        this.currentPageIndex=0;
    }

    catch (error) {
        console.error('Error loading bookmark from localStorage:', error);
        this.currentPageIndex=0; // Default on error
    }
}

// --- Page Number Update (ARIA + RTL Buttons) ---
updatePageNumber() {
    if ( !this.isInitialized) {
        // Don't update before init completes
        this.pageNumber.textContent="- / -";

        if (this.pageSlider) {
            this.pageSlider.value=1;
            this.pageSlider.max=1;
            this.pageSlider.disabled=true;
            this.pageSlider.removeAttribute('aria-valuetext');
        }

        if(this.prevButton) this.prevButton.disabled=true;
        if(this.nextButton) this.nextButton.disabled=true;
        if(this.prevZone) this.prevZone.style.pointerEvents='none';
        if(this.nextZone) this.nextZone.style.pointerEvents='none';
        return;
    }

    const displayedPage=this.currentPageIndex+1;

    const pageNumberText=`$ {
        displayedPage
    }

    / $ {
        this.totalPages
    }

    `;
    // Determine first/last page status based on index
    const isFirstPage=this.currentPageIndex===0;
    const isLastPage=this.currentPageIndex>=this.totalPages - 1;

    // Determine button disabled state based on reading direction AND position
    const disablePrevBtn=(this.readingDirection==='rtl') ? isLastPage : isFirstPage;
    const disableNextBtn=(this.readingDirection==='rtl') ? isFirstPage : isLastPage;

    // Determine aria labels based on reading direction
    const prevLabel=this.readingDirection==='rtl' ? '次のページ' : '前のページ'; // RTL Prev button -> Next Page visually
    const nextLabel=this.readingDirection==='rtl' ? '前のページ' : '次のページ'; // RTL Next button -> Prev Page visually

    // Update UI elements within requestAnimationFrame for potential performance benefits
    requestAnimationFrame(()=> {
            if (this.pageNumber.textContent !==pageNumberText) {
                this.pageNumber.textContent=pageNumberText;
            }

            if (this.pageSlider && parseInt(this.pageSlider.value) !==displayedPage) {
                this.pageSlider.value=displayedPage;
            }

            // Set ARIA attribute for slider
            if (this.pageSlider) {
                this.pageSlider.setAttribute('aria-valuetext', `ページ $ {
                        displayedPage
                    }

                    / $ {
                        this.totalPages
                    }

                    `);
            }

            // Update button states and labels
            if (this.prevButton) {
                this.prevButton.disabled=disablePrevBtn;
                this.prevButton.setAttribute('aria-label', prevLabel);
            }

            if (this.nextButton) {
                this.nextButton.disabled=disableNextBtn;
                this.nextButton.setAttribute('aria-label', nextLabel);
            }

            if (this.prevZone) {
                this.prevZone.style.pointerEvents=disablePrevBtn ? 'none' : 'auto';
                this.prevZone.setAttribute('aria-label', prevLabel);
            }

            if (this.nextZone) {
                this.nextZone.style.pointerEvents=disableNextBtn ? 'none' : 'auto';
                this.nextZone.setAttribute('aria-label', nextLabel);
            }
        });
}

// --- Page Loading and Preloading (RTL Handled) ---
async loadPage(pageIndex) {

    // Basic validation
    if (pageIndex < 0 || pageIndex >=this.totalPages) {
        this.showError(`Invalid page index: $ {
                pageIndex + 1
            }

            `);

        throw new Error(`Invalid page index: $ {
                pageIndex
            }

            `);
    }

    const pageData=this.allPages[pageIndex];

    if ( !pageData || !pageData.image_url) {
        this.showError(`Page data not found for page $ {
                pageIndex + 1
            }

            .`);

        throw new Error(`Missing page data for index $ {
                pageIndex
            }

            `);
    }

    // Avoid reloading the exact same image if it's already displayed and not in error state
    if (this.currentPage.dataset.imageUrl===pageData.image_url && this.currentPage.dataset.imageUrl !=='error') {
        console.log("Image already loaded:", pageData.image_url);
        // Ensure loading state is correct even if skipping
        this.isLoading=false;
        this.loadingSpinner.style.display='none';
        return; // Resolve promise immediately as it's loaded
    }

    console.log(`Loading image for page index $ {
            pageIndex
        }

        : $ {
            pageData.image_url
        }

        `);
    this.isLoading=true;
    this.loadingSpinner.style.display='block';
    this.errorMessage.style.display='none';
    // Optionally dim current image slightly?
    // this.currentPage.style.opacity = '0.8';

    try {
        // Use the promise-based image loader
        await this.loadImageWithPromise(this.currentPage, pageData.image_url);

        // Reset potential dimming
        // this.currentPage.style.opacity = '1';
        console.log(`Successfully loaded $ {
                pageData.image_url
            }

            `);
        // Preload adjacent pages after successful load
        this.preloadAdjacentPages(pageIndex);
    }

    catch (error) {
        console.error(`Failed to load image for page index $ {
                pageIndex
            }

            : $ {
                error.message
            }

            `);
        this.showError(error.message); // Show the specific error from loadImageWithPromise
        // Reset potential dimming
        // this.currentPage.style.opacity = '1';
        // Rethrow the error so goToPage's catch/finally can react
        throw error;
    }

    finally {
        // Ensure loading state is reset and spinner hidden
        this.isLoading=false;
        this.loadingSpinner.style.display='none';
        // updatePageNumber is called in goToPage's finally block
    }
}

// Modified loadImage function returning a Promise
loadImageWithPromise(imgElement, src) {
    return new Promise((resolve, reject)=> {
            if ( !imgElement) {
                // This should ideally not happen due to constructor checks
                return reject(new Error("Target image element is missing."));
            }

            const img=new Image();

            img.onload=()=> {
                console.log(`Image loaded in background: $ {
                        src
                    }

                    `);
                // Set src AFTER load to ensure smooth transition (or placeholder visibility)
                imgElement.src=src;
                imgElement.style.backgroundColor='transparent'; // Remove placeholder bg
                imgElement.dataset.imageUrl=src; // Store current URL, mark as successfully loaded
                imgElement.removeAttribute('data-load-error'); // Clear error state if any
                resolve();
            }

            ;

            img.onerror=(event)=> {
                // Extract more specific error if possible, otherwise use a generic message
                const errorDetail=typeof event==='string' ? event : (event && event.type ? event.type : 'unknown');

                console.error(`Error loading image: $ {
                        src
                    }

                    `, errorDetail);
                imgElement.style.backgroundColor='var(--error-color, #500)'; // Indicate error visually
                // Optionally set a broken image placeholder
                // imgElement.src = "path/to/broken-image.png";
                imgElement.dataset.imageUrl='error'; // Mark as error state
                imgElement.setAttribute('data-load-error', 'true');
                // Try to extract filename for user message
                let filename='file';

                try {
                    filename=new URL(src).pathname.split('/').pop() || 'file';
                }

                catch (e) {}

                reject(new Error(`Image ($ {
                                filename
                            }) failed to load.`));
            }

            ;

            // Set placeholder background if needed (first load or previous error)
            if ( !imgElement.src || imgElement.src.startsWith ('data:') || imgElement.dataset.imageUrl==='error') {
                imgElement.style.backgroundColor='#333'; // Placeholder bg
                // Use a transparent pixel GIF to ensure layout dimensions are calculated correctly initially
                imgElement.src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            }

            // If a previous valid image exists, it remains visible while the new one loads.

            console.log(`Starting background load for: $ {
                    src
                }

                `);
            img.src=src; // Start loading the image in the background Image object
        });
}


preloadAdjacentPages(currentIndex) {
    const pagesToPreload=new Set();

    for (let i=1; i <=this.PRELOAD_DEPTH; i++) {
        // Preload "next" page visually (lower index in RTL, higher in LTR)
        const nextPageIndex=(this.readingDirection==='rtl') ? currentIndex - i: currentIndex + i;

        if (nextPageIndex >=0 && nextPageIndex < this.totalPages) {
            pagesToPreload.add(nextPageIndex);
        }

        // Preload "previous" page visually (higher index in RTL, lower in LTR)
        const prevPageIndex=(this.readingDirection==='rtl') ? currentIndex+i : currentIndex - i;

        if (prevPageIndex >=0 && prevPageIndex < this.totalPages) {
            pagesToPreload.add(prevPageIndex);
        }
    }

    if (pagesToPreload.size > 0) {

        // console.log("Preloading indices:", Array.from(pagesToPreload));
        pagesToPreload.forEach(index=> {
                const page=this.allPages[index];

                if (page && page.image_url) {
                    const img=new Image();

                    // Low priority loading hint if supported
                    if ('loading' in HTMLImageElement.prototype) {
                        img.loading='lazy'; // Suggests non-critical resource
                    }

                    // Assign src to start preload. Error handling is optional here.
                    img.src=page.image_url;
                    // Optional: Add minimal error logging for preloads
                    // img.onerror = () => console.warn(`Failed to preload image: ${page.image_url}`);
                }
            });
    }
}

showError(message) {
    console.error("Displaying error:", message);
    this.loadingSpinner.style.display='none'; // Hide spinner first
    this.errorText.textContent=message;
    this.errorMessage.style.display='block';
    this.isLoading=false; // Ensure loading state is reset
    // Do not disable navigation buttons, allow retry
}


// --- Pointer Event Handlers (RTL Swipe Handled, Constants Used) ---
handlePointerDown(e) {
    // Ignore non-primary button interactions or when not initialized
    if (e.button !==0 || !this.isInitialized) return;

    // Store pointer info, including start time for tap detection
    this.activePointers.set(e.pointerId, {
        x: e.clientX,
        y: e.clientY,
        startTime: Date.now() // Record start time for tap duration
    });

// Capture the pointer to ensure subsequent events are received
try {
    e.target.setPointerCapture(e.pointerId);
}

catch (err) {
    console.warn("Failed to capture pointer:", err.message);
}


this.showUI(); // Show UI on interaction
this.clearUiHideTimeout(); // Keep UI visible during interaction

if (this.activePointers.size===1) {
    // First pointer down
    this.isZooming=false; // Reset zooming flag
    this.isPanning=this.scale>1; // Only allow panning if zoomed
    this.touchStartX=e.clientX;
    this.touchStartY=e.clientY;

    // lastTapTime is updated on pointer *up* to measure interval between taps
    if (this.isPanning) {
        this.panStartX=this.translateX;
        this.panStartY=this.translateY;
        this.viewerContainer.style.cursor='grabbing';
    }

    else {
        this.viewerContainer.style.cursor='grab';
    }
}

else if (this.activePointers.size===2) {
    // Second pointer down (pinch zoom start)
    this.isZooming=true;
    this.isPanning=false; // Stop panning when starting to zoom
    const pointers=Array.from(this.activePointers.values());
    this.initialDistance=Math.hypot(pointers[1].x - pointers[0].x, pointers[1].y - pointers[0].y);
    this.initialScale=this.scale;
    // Calculate pinch center relative to the zoom container's *visual* position
    const rect=this.zoomContainer.getBoundingClientRect();
    this.pinchCenterX=((pointers[0].x + pointers[1].x) / 2) - rect.left;
    this.pinchCenterY=((pointers[0].y + pointers[1].y) / 2) - rect.top;
}
}

handlePointerMove(e) {
    if ( !this.activePointers.has(e.pointerId) || !this.isInitialized) return;

    // Update pointer position in our map
    const currentPointer=this.activePointers.get(e.pointerId);

    if (currentPointer) {
        currentPointer.x=e.clientX;
        currentPointer.y=e.clientY;
    }

    if (this.isZooming && this.activePointers.size >=2) {
        // Handle >= 2 pointers for zoom
        e.preventDefault(); // Prevent page scroll/etc. during zoom
        const pointers=Array.from(this.activePointers.values());
        // Use the first two pointers for distance calculation
        const currentDistance=Math.hypot(pointers[1].x - pointers[0].x, pointers[1].y - pointers[0].y);

        if (this.initialDistance > 0) {
            // Avoid division by zero
            const scaleFactor=currentDistance / this.initialDistance;
            // Clamp scale between 1x and max zoom level
            const newScale=Math.max(1, Math.min(this.initialScale * scaleFactor, this.MAX_ZOOM_SCALE));

            // Calculate translation adjustment based on pinch center relative to current scale/translation
            // (Origin point calculation for smooth zoom around pinch center)
            const deltaScale=newScale - this.scale;
            // Pinch center relative to the *unscaled* content origin (center)
            const originX=(this.pinchCenterX - this.translateX) / this.scale;
            const originY=(this.pinchCenterY - this.translateY) / this.scale;

            // Adjust translation to keep the pinch point stationary relative to the viewport
            this.translateX -=originX * deltaScale;
            this.translateY -=originY * deltaScale;

            this.scale=newScale;

            this.applyPanBoundaries(); // Apply boundaries after scaling and translating
            this.updateZoom(false); // Update transform without transition during move
        }
    }

    else if (this.isPanning && this.activePointers.size===1) {
        // Only pan with one pointer
        e.preventDefault(); // Prevent default panning behavior if any (e.g., text selection)
        const currentX=e.clientX;
        const currentY=e.clientY;
        const deltaX=currentX - this.touchStartX;
        const deltaY=currentY - this.touchStartY;

        this.translateX=this.panStartX+deltaX;
        this.translateY=this.panStartY+deltaY;

        this.applyPanBoundaries(); // Keep within bounds during pan
        this.updateZoom(false); // Update transform without transition
    }
}


handlePointerEnd(e) {
    if ( !this.activePointers.has(e.pointerId) || !this.isInitialized) return;

    const pointerUpTime=Date.now();
    const pointerId=e.pointerId;
    const startPointerData=this.activePointers.get(pointerId); // Get start data if needed

    // Release pointer capture
    try {
        e.target.releasePointerCapture(pointerId);
    }

    catch(err) {
        console.warn("Failed to release pointer:", err.message);
    }

    this.activePointers.delete(pointerId);

    const tapInterval=pointerUpTime - this.lastTapTime; // Time since last pointer up
    let isDoubleTap=false;

    // --- Double Tap ---
    // Check if this was the last active pointer and timing is right
    if (this.activePointers.size===0 && e.pointerType !=='mouse' && // Typically disable for mouse
        tapInterval < this.DOUBLE_TAP_TIMEOUT_MS && startPointerData && (pointerUpTime - startPointerData.startTime) < this.DOUBLE_TAP_TIMEOUT_MS // Check tap duration too

        /* && tapInterval > this.MIN_TAP_DURATION_MS */
    ) {
        // Optional: Minimum interval to avoid accidental double taps

        isDoubleTap=true;
        const rect=this.viewerContainer.getBoundingClientRect();
        const tapX=e.clientX - rect.left;
        const tapY=e.clientY - rect.top;

        if (this.scale <=1.1) {
            // If not zoomed or only slightly
            const targetScale=this.DOUBLE_TAP_ZOOM_SCALE; // Use constant
            // Calculate translation to center the tap point
            const containerCenterX=this.viewerContainer.clientWidth / 2;
            const containerCenterY=this.viewerContainer.clientHeight / 2;

            // Target translation calculation: move the tapped point (tapX, tapY) towards the center
            // Formula: Center - (TapPoint * Scale)
            this.translateX=containerCenterX - (tapX * targetScale);
            this.translateY=containerCenterY - (tapY * targetScale);
            this.scale=targetScale;

            console.log("Double tap zoom IN");
        }

        else {
            // Zoom out on double tap if already zoomed in
            this.resetZoom();
            console.log("Double tap zoom OUT");
        }

        this.applyPanBoundaries(); // Apply boundaries after zoom
        this.updateZoom(true); // Zoom with transition
    }

    // Update lastTapTime for the *next* double tap detection
    if (this.activePointers.size===0) {
        this.lastTapTime=pointerUpTime;
    }


    // --- Swipe Detection (RTL Handled) ---
    // Only detect swipe if it wasn't a double tap, not zooming, scale is near 1x, and it was the last pointer up
    if ( !isDoubleTap && !this.isZooming && this.scale <=1.1 && this.activePointers.size===0 && startPointerData) {
        const touchEndX=e.clientX;
        const touchEndY=e.clientY;
        const deltaX=touchEndX - this.touchStartX; // Use start position from pointerdown
        const deltaY=touchEndY - this.touchStartY;
        const swipeDuration=pointerUpTime - startPointerData.startTime;

        // Check for horizontal swipe: significant X movement, limited Y movement, reasonable duration
        if (Math.abs(deltaX) > this.SWIPE_THRESHOLD_PX && Math.abs(deltaY) < this.SWIPE_VERTICAL_THRESHOLD_PX && swipeDuration < 500) {
            // Add duration limit to distinguish from slow drag

            // Horizontal swipe detected
            if (deltaX > 0) {
                // Swiped right
                console.log("Swipe Right detected");
                if (this.readingDirection==='rtl') this.nextPage(); // RTL: Right swipe -> Prev Page (index減)
                else this.prevPage(); // LTR: Right swipe -> Prev Page (index減)
            }

            else {
                // Swiped left
                console.log("Swipe Left detected");
                if (this.readingDirection==='rtl') this.prevPage(); // RTL: Left swipe -> Next Page (index増)
                else this.nextPage(); // LTR: Left swipe -> Next Page (index増)
            }

            // Prevent swipe from also triggering click on nav zones if needed
            // e.preventDefault(); // Use with caution
        }
    }


    // --- State Reset ---
    // If zooming was active and pointer count drops below 2, stop zooming mode
    if (this.isZooming && this.activePointers.size < 2) {
        this.isZooming=false;
    }

    // If panning was active and the last pointer is up, stop panning mode
    if (this.isPanning && this.activePointers.size===0) {
        this.isPanning=false;
        this.viewerContainer.style.cursor='grab'; // Reset cursor
    }

    // If this was the last pointer up
    if (this.activePointers.size===0) {

        // Snap back to 1x if zoom is very close to 1 after interaction ends (and wasn't a double tap zoom)
        if (this.scale < 1.05 && this.scale > 0.95 && !isDoubleTap) {
            this.resetZoom();
        }

        // Reset cursor if it was left in grabbing state
        if (this.viewerContainer.style.cursor==='grabbing') {
            this.viewerContainer.style.cursor='grab';
        }

        // Schedule UI hide only when all interactions have ended
        this.scheduleUiHide();
    }
}

handlePointerCancel(e) {
    if (this.activePointers.has(e.pointerId)) {
        console.log("Pointer cancelled:", e.pointerId);

        try {
            e.target.releasePointerCapture(e.pointerId);
        }

        catch(err) {
            console.warn("Failed to release cancelled pointer:", err.message);
        }

        this.activePointers.delete(e.pointerId);

        // Reset interaction states if cancellation disrupts them
        if (this.isZooming && this.activePointers.size < 2) {
            this.isZooming=false;
            console.log("Zooming cancelled.");
        }

        if (this.isPanning && this.activePointers.size===0) {
            this.isPanning=false;
            this.viewerContainer.style.cursor='grab';
            console.log("Panning cancelled.");
        }

        // Reset to base state if needed (e.g., slight zoom)
        if (this.activePointers.size===0) {
            if (this.scale < 1.05 && this.scale > 0.95) {
                console.log("Resetting zoom after cancel.");
                this.resetZoom();
            }

            this.viewerContainer.style.cursor='grab';
            this.scheduleUiHide(); // Schedule hide if interaction fully cancelled
        }
    }
}


// --- Zooming and Panning Logic ---
updateZoom(useTransition=false) {
    // Apply transition style based on parameter
    this.zoomContainer.style.transition=useTransition ? 'transform 0.3s ease': 'none';

    // Use translate3d for potential hardware acceleration benefits
    // Clamp scale just in case it somehow becomes invalid
    const clampedScale=Math.max(0.1, this.scale); // Prevent scale being zero or negative

    this.zoomContainer.style.transform=`translate3d($ {
            this.translateX
        }

        px, $ {
            this.translateY
        }

        px, 0) scale($ {
            clampedScale
        })`;
}


resetZoom() {
    if (this.scale !==1 || this.translateX !==0 || this.translateY !==0) {
        console.log("Resetting zoom and pan.");
        this.scale=1;
        this.translateX=0;
        this.translateY=0;
        this.isPanning=false; // Ensure panning state is reset
        this.viewerContainer.style.cursor='grab'; // Reset cursor
        this.updateZoom(true); // Reset with transition
    }
}

applyPanBoundaries() {
    // Get container dimensions; return if not valid or not zoomed
    const containerWidth=this.viewerContainer.clientWidth;
    const containerHeight=this.viewerContainer.clientHeight;

    if ( !containerWidth || !containerHeight || this.scale <=1) {
        // No panning needed if not zoomed or container size is zero
        this.translateX=0;
        this.translateY=0;
        return;
    }

    // Calculate the dimensions of the scaled content (assuming content fits container at scale 1)
    const contentWidth=containerWidth * this.scale;
    const contentHeight=containerHeight * this.scale;

    // Calculate maximum allowed translation offset from the center (0,0)
    // This is half the difference between the scaled content size and the container size
    const maxTranslateX=Math.max(0, (contentWidth - containerWidth) / 2);
    const maxTranslateY=Math.max(0, (contentHeight - containerHeight) / 2);

    // Clamp the current translation values within the calculated bounds [-max, +max]
    this.translateX=Math.max(-maxTranslateX, Math.min(maxTranslateX, this.translateX));
    this.translateY=Math.max(-maxTranslateY, Math.min(maxTranslateY, this.translateY));
}


// --- Keyboard (RTL Handled) ---
handleKeyDown(e) {
    if ( !this.isInitialized || this.isLoading) return;
    // Ignore keys if focus is inside an input element or the episode modal list items
    const activeElement=document.activeElement;

    if (activeElement && (activeElement.tagName==='INPUT' || activeElement.tagName==='TEXTAREA' || activeElement.closest('#episode-list'))) {

        // Allow default behavior for Escape within modal list
        if (e.key==='Escape' && this.episodeOverlay.classList.contains('active')) {
            // Handled below
        }

        else {
            return;
        }
    }

    // Close episode modal on Escape (priority)
    if (e.key==='Escape' && this.episodeOverlay.classList.contains('active')) {
        this.hideEpisodeList();
        e.preventDefault();
        // Optionally return focus to episode button
        this.episodeButton.focus();
        return;
    }

    // Define page turning functions based on reading direction
    const prevAction=this.readingDirection==='rtl' ? this.nextPage : this.prevPage; // "Visually Previous" action
    const nextAction=this.readingDirection==='rtl' ? this.prevPage : this.nextPage; // "Visually Next" action

    let pageChanged=false; // Flag to prevent UI hide if page changed

    switch (e.key) {
        case 'ArrowLeft':
            case 'PageUp': // Typically moves towards the beginning
            e.preventDefault();
        prevAction.call(this);
        pageChanged=true;
        break;

        case 'ArrowRight':
            case ' ': // Spacebar often used for next page
            case 'PageDown': // Typically moves towards the end
            e.preventDefault();
        nextAction.call(this);
        pageChanged=true;
        break;

        case 'Home':
            e.preventDefault();

        if (this.currentPageIndex !==0) {
            this.goToPage(0);
            pageChanged=true;
        }

        break;
        case 'End': e.preventDefault();
        const lastIndex=this.totalPages - 1;

        if (this.currentPageIndex !==lastIndex) {
            this.goToPage(lastIndex);
            pageChanged=true;
        }

        break;

        case 'f': // Use 'f' or F11 for fullscreen
        case 'F11': e.preventDefault();
        this.toggleFullscreen();
        break;

        case 'Escape': // Hide UI if visible (and modal is not open - handled above)

        if (this.isUIVisible) {
            this.hideUI();
            e.preventDefault();
        }

        break;
        // '+' and '-' for zoom could be added here
        // case '+':
        //     e.preventDefault();
        //     // Implement zoom in logic
        //     break;
        // case '-':
        //     e.preventDefault();
        //     // Implement zoom out logic
        //     break;
    }

    // If a page change key was pressed, ensure UI is shown
    if (pageChanged) {
        this.showUI();
    }
}

handleResize() {
    if ( !this.isInitialized) return;
    console.log("Window resized");
    // Reset zoom and re-apply boundaries for the new size
    this.resetZoom(); // Resets scale and translation, applies with transition
    // updateZoom(false) is called within resetZoom if changes occur
    // Need to re-apply boundaries immediately in case content aspect ratio changes relative to viewport
    this.applyPanBoundaries();
    this.updateZoom(false); // Apply boundary correction immediately without transition

    // Consider potential UI layout shifts if resize is drastic
    // (e.g., re-center overlays if needed, though CSS should handle most)
}
}

// End of MangaViewer Class

// Initialize viewer once DOM is ready
document.addEventListener('DOMContentLoaded', ()=> {
        if ( !window.mangaViewerInstance) {
            console.log("DOM Ready, initializing MangaViewer...");
            window.mangaViewerInstance=new MangaViewer();

            // Start the asynchronous initialization process
            // Handle potential errors during the async init phase
            window.mangaViewerInstance.init().catch(error=> {
                    console.error("Viewer final initialization failed:", error);
                    // Display a more persistent error if init itself fails after constructor succeeds
                    const fallbackError=document.getElementById('init-error-fallback');

                    if (fallbackError && !fallbackError.textContent.includes('final initialization failed')) {
                        fallbackError.textContent +=' Final initialization failed. Please reload.';
                    }
                });
        }

        else {
            console.log("MangaViewer instance already exists.");
        }
    });
</script>
</body>
</html>
