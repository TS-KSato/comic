<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Commercial Manga Viewer</title>
    <style>
        /* --- CSS (設定関連を削除し簡略化) --- */
        :root {
            --primary-color: #4a6cf7;
            --secondary-color: #ff6b6b;
            /* Simplified: Defaulting to light theme variables */
            --background-color: #ffffff;
            --text-color: #333333;
            --overlay-background: rgba(0, 0, 0, 0.7);
            --overlay-text: #ffffff;
            --button-background: rgba(255, 255, 255, 0.2);
            --button-hover: rgba(255, 255, 255, 0.4);
            --slider-track: rgba(255, 255, 255, 0.3);
            --slider-thumb: #ffffff;
            --spinner-color: #ffffff;
            --error-color: #ff4d4d;
        }

        /* Optional: Keep dark theme styles if system preference detection is desired, */
        /* but remove the manual switching buttons/logic */
        @media (prefers-color-scheme: dark) {
            :root {
                --background-color: #121212;
                --text-color: #f1f1f1;
                --overlay-background: rgba(0, 0, 0, 0.8);
            }
        }


        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: fixed;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #viewer-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
        }

        #viewer-container:active {
            cursor: grabbing;
        }

        #zoom-container {
            width: 100%;
            height: 100%;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            transform-origin: center;
            /* 動的な変更時のみトランジションを適用する（JSで制御） */
            transition: none;
            /* ハードウェアアクセラレーションを有効化 */
            transform: translate3d(0, 0, 0);
            will-change: transform;
        }

        #manga-page-container {
            position: relative;
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .manga-page {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            /* Default fit mode */
            transform-origin: center;
            transition: opacity 0.3s ease;
            pointer-events: none;
            flex-shrink: 0;
            background-color: #333;
            /* Placeholder */
            /* ハードウェアアクセラレーションを有効化 */
            transform: translateZ(0);
            will-change: transform, opacity;
        }

        /* Navigation zones */
        .nav-zone {
            position: absolute;
            height: 100%;
            width: 30%;
            top: 0;
            z-index: 10;
        }

        #prev-zone {
            left: 0;
            cursor: pointer;
        }

        #next-zone {
            right: 0;
            cursor: pointer;
        }

        #center-zone {
            left: 30%;
            width: 40%;
            cursor: pointer;
        }

        /* UI Overlays */
        .ui-overlay {
            position: absolute;
            left: 0;
            width: 100%;
            padding: 15px;
            color: var(--overlay-text);
            background-color: var(--overlay-background);
            z-index: 20;
            transition: transform 0.3s ease, opacity 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            /* ハードウェアアクセラレーションを有効化 */
            transform: translate3d(0, 0, 0);
            will-change: transform, opacity;
        }

        .ui-overlay>* {
            pointer-events: auto;
        }

        #top-overlay {
            top: 0;
            transform: translateY(-100%);
        }

        #bottom-overlay {
            bottom: 0;
            transform: translateY(100%);
        }

        #viewer-container.show-ui #top-overlay,
        #viewer-container.show-ui #bottom-overlay {
            transform: translateY(0);
            opacity: 1;
        }

        #viewer-container.ui-hidden .ui-overlay {
            opacity: 0;
            transform: translateY(-100%)
                /* or translateY(100%) for bottom */
            ;
            pointer-events: none;
        }

        /* Buttons and controls */
        .ui-button {
            background-color: var(--button-background);
            border: none;
            color: var(--overlay-text);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .ui-button:hover,
        .ui-button:active {
            background-color: var(--button-hover);
        }

        .ui-button:disabled {
            opacity: 0.5;
            cursor: default;
            background-color: var(--button-background);
            /* Prevent hover effect */
        }


        .ui-button svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        /* Page slider */
        #page-slider-container {
            flex-grow: 1;
            margin: 0 15px;
            display: flex;
            align-items: center;
        }

        #page-slider {
            width: 100%;
            height: 8px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background: var(--slider-track);
            border-radius: 4px;
            outline: none;
        }

        #page-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
        }

        #page-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
            border: none;
        }

        /* Loading spinner */
        #loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--spinner-color);
            animation: spin 1s ease-in-out infinite;
            z-index: 40;
            display: none;
        }

        @keyframes spin {
            from {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Error message */
        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--error-color);
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            max-width: 80%;
            text-align: center;
            z-index: 40;
            display: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        #retry-button {
            margin-top: 15px;
            padding: 8px 15px;
            background-color: white;
            color: var(--error-color);
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        #retry-button:hover {
            background-color: #eee;
        }

        #episode-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--overlay-background);
            z-index: 50;
            display: none;
            justify-content: center;
            align-items: center;
        }

        #episode-overlay.active {
            display: flex;
        }

        .modal-content {
            width: 80%;
            max-width: 500px;
            background-color: var(--background-color);
            border-radius: 8px;
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        #episode-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .episode-item {
            padding: 12px;
            background-color: rgba(128, 128, 128, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .episode-item:hover {
            background-color: rgba(128, 128, 128, 0.2);
        }

        .episode-item.current {
            border-left: 3px solid var(--primary-color);
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="viewer-container" class="show-ui"> <!-- Start with UI visible -->
        <!-- Zoom container -->
        <div id="zoom-container">
            <!-- Manga page container (Simplified: Only one page element needed) -->
            <div id="manga-page-container">
                <img alt="Manga page" class="manga-page" id="current-page">
                <!-- Removed second-page -->
            </div>
        </div>

        <!-- Navigation zones -->
        <div class="nav-zone" id="prev-zone" aria-label="Previous Page"></div>
        <div class="nav-zone" id="center-zone" aria-label="Toggle UI"></div>
        <div class="nav-zone" id="next-zone" aria-label="Next Page"></div>

        <!-- Top UI overlay (Simplified: No settings button) -->
        <div class="ui-overlay" id="top-overlay">
            <div id="content-title">Loading...</div>
            <div id="page-number"> - / - </div>
            <!-- Removed settings button -->
        </div>

        <!-- Bottom UI overlay -->
        <div class="ui-overlay" id="bottom-overlay">
            <button class="ui-button" id="prev-button" aria-label="Previous Page">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M15.41,16.59L10.83,12l4.58-4.59L14,6l-6,6l6,6L15.41,16.59z"></path>
                </svg>
            </button>

            <div id="page-slider-container">
                <input type="range" min="1" max="1" value="1" id="page-slider" aria-label="Page Slider">
            </div>

            <button class="ui-button" id="next-button" aria-label="Next Page">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M8.59,16.59L13.17,12L8.59,7.41L10,6l6,6l-6,6L8.59,16.59z"></path>
                </svg>
            </button>

            <button class="ui-button" id="fullscreen-button" aria-label="Toggle Fullscreen">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path id="fullscreen-enter-icon"
                        d="M7,14H5v5h5v-2H7V14z M5,10h2V7h3V5H5V10z M17,17h-3v2h5v-5h-2V17z M14,5v2h3v3h2V5H14z"></path>
                    <path id="fullscreen-exit-icon"
                        d="M5,16h3v3h2v-5H5V16z M8,5H5v5h2V7h3V5z M14,19h2v-3h3v-2h-5V19z M16,8h3V5h-2v3h-3V8z"
                        style="display: none;"></path>
                </svg>
            </button>

            <div class="ui-overlay" id="bottom-overlay">
                <!-- bottom-overlay の内容... -->
                <div id="episode-navigation">
                    <button class="ui-button" id="episode-btn" aria-label="エピソード選択">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path
                                d="M3,13h2v-2H3V13z M3,17h2v-2H3V17z M3,9h2V7H3V9z M7,13h14v-2H7V13z M7,17h14v-2H7V17z M7,7v2h14V7H7z">
                            </path>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="episode-overlay" class="modal-overlay">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>エピソード選択</h2>
                        <button id="close-episode-btn" class="ui-button">×</button>
                    </div>
                    <div id="episode-list"></div>
                </div>
            </div>

        </div>

        <!-- Settings panel Removed -->

        <!-- Loading spinner -->
        <div id="loading-spinner" aria-label="Loading" role="status"></div>

        <!-- Error message -->
        <div id="error-message" role="alert">
            <div id="error-text">読み込みに失敗しました。</div>
            <button id="retry-button">再試行</button>
        </div>
    </div>

    <script>
        // Main viewer class
        class MangaViewer {
            constructor() {
                // DOM elements (Simplified)
                this.viewerContainer = this.getElement('viewer-container');
                this.zoomContainer = this.getElement('zoom-container');
                this.pageContainer = this.getElement('manga-page-container');
                this.currentPage = this.getElement('current-page');
                // Removed: this.secondPage
                this.topOverlay = this.getElement('top-overlay');
                this.bottomOverlay = this.getElement('bottom-overlay');
                this.pageSlider = this.getElement('page-slider');
                this.pageNumber = this.getElement('page-number');
                this.contentTitle = this.getElement('content-title');
                this.loadingSpinner = this.getElement('loading-spinner');
                this.errorMessage = this.getElement('error-message');
                this.errorText = this.getElement('error-text');
                this.retryButton = this.getElement('retry-button');
                // Removed: this.settingsPanel

                // Navigation zones
                this.prevZone = this.getElement('prev-zone');
                this.nextZone = this.getElement('next-zone');
                this.centerZone = this.getElement('center-zone');

                // Buttons (Simplified)
                this.prevButton = this.getElement('prev-button');
                this.nextButton = this.getElement('next-button');
                this.fullscreenButton = this.getElement('fullscreen-button');
                this.fullscreenEnterIcon = this.getElement('fullscreen-enter-icon');
                this.fullscreenExitIcon = this.getElement('fullscreen-exit-icon');
                // Removed: this.settingsButton, this.closeSettingsButton

                // Removed: Settings options references

                // State variables (Simplified)
                this.currentPageIndex = 0;
                this.totalPages = 0;
                this.allPages = [];
                // Removed: isDoublePage (always single)
                this.readingDirection = 'rtl'; // Default, updated from data
                // Removed: fitMode (using CSS default)
                // Removed: theme (using CSS default/system)
                this.isUIVisible = true;
                // Removed: isSettingsVisible
                this.uiHideTimeout = null;
                this.isLoading = false;

                // Touch handling variables
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.panStartX = 0;
                this.panStartY = 0;
                this.lastTapTime = 0;

                // Zoom variables
                this.scale = 1;
                this.translateX = 0;
                this.translateY = 0;
                this.initialDistance = 0;
                this.isZooming = false;
                this.isPanning = false;

                // Mock manga data (corrected page numbers in original data)
                this.mangaData = {
                    id: 'manga123',
                    title: 'KARMA',
                    frontMatter: [
                        { page_number: 1, image_url: 'i_001.jpg', type: 'cover' },
                        { page_number: 2, image_url: 'i_002.jpg', type: 'contents' }
                    ],
                    episodes: [
                        { id: 'episode1', title: '第1話', pages: [{ page_number: 3, image_url: 'i_003.jpg' }, { page_number: 4, image_url: 'i_004.jpg' }, { page_number: 5, image_url: 'i_005.jpg' }, { page_number: 6, image_url: 'i_006.jpg' }, { page_number: 7, image_url: 'i_007.jpg' }, { page_number: 8, image_url: 'i_008.jpg' }, { page_number: 9, image_url: 'i_009.jpg' }, { page_number: 10, image_url: 'i_010.jpg' }, { page_number: 11, image_url: 'i_011.jpg' }, { page_number: 12, image_url: 'i_012.jpg' }, { page_number: 13, image_url: 'i_013.jpg' }] },
                        { id: 'episode2', title: '第2話', pages: [{ page_number: 14, image_url: 'i_014.jpg' }, { page_number: 15, image_url: 'i_015.jpg' }, { page_number: 16, image_url: 'i_016.jpg' }, { page_number: 17, image_url: 'i_017.jpg' }, { page_number: 18, image_url: 'i_018.jpg' }, { page_number: 19, image_url: 'i_019.jpg' }, { page_number: 20, image_url: 'i_020.jpg' }, { page_number: 21, image_url: 'i_021.jpg' }, { page_number: 22, image_url: 'i_022.jpg' }] },
                        { id: 'episode3', title: '第3話', pages: [{ page_number: 23, image_url: 'i_023.jpg' }, { page_number: 24, image_url: 'i_024.jpg' }, { page_number: 25, image_url: 'i_025.jpg' }, { page_number: 26, image_url: 'i_026.jpg' }, { page_number: 27, image_url: 'i_027.jpg' }, { page_number: 28, image_url: 'i_028.jpg' }, { page_number: 29, image_url: 'i_029.jpg' }, { page_number: 30, image_url: 'i_030.jpg' }, { page_number: 31, image_url: 'i_031.jpg' }] },
                        { id: 'episode4', title: '第4話', pages: [{ page_number: 32, image_url: 'i_032.jpg' }, { page_number: 33, image_url: 'i_033.jpg' }, { page_number: 34, image_url: 'i_034.jpg' }, { page_number: 35, image_url: 'i_035.jpg' }, { page_number: 36, image_url: 'i_036.jpg' }, { page_number: 37, image_url: 'i_037.jpg' }, { page_number: 38, image_url: 'i_038.jpg' }, { page_number: 39, image_url: 'i_039.jpg' }, { page_number: 40, image_url: 'i_040.jpg' }] },
                        { id: 'episode5', title: '第5話', pages: [{ page_number: 41, image_url: 'i_041.jpg' }, { page_number: 42, image_url: 'i_042.jpg' }, { page_number: 43, image_url: 'i_043.jpg' }, { page_number: 44, image_url: 'i_044.jpg' }, { page_number: 45, image_url: 'i_045.jpg' }, { page_number: 46, image_url: 'i_046.jpg' }, { page_number: 47, image_url: 'i_047.jpg' }, { page_number: 48, image_url: 'i_048.jpg' }] }
                    ],
                    // Removed: currentEpisodeIndex (no longer needed for page loading)
                    reading_direction: 'rtl'
                };

                if (!this.viewerContainer || !this.currentPage) {
                    console.error("初期化エラー: 必須のDOM要素が見つかりません。");
                    this.showError("ビューアの初期化に失敗しました。ページをリロードしてください。");
                    return;
                }

                this.init();
            }

            getElement(id) {
                const element = document.getElementById(id);
                if (!element) {
                    console.warn(`Element with ID '${id}' not found.`);
                }
                return element;
            }

            init() {
                this.setupEventListeners();
                // Removed settings loading
                this.loadMangaData();
                this.scheduleUiHide();
            }

            async fetchMangaData() {
                this.loadingSpinner.style.display = 'block';
                this.errorMessage.style.display = 'none';
                this.isLoading = true;
                console.log("Fetching manga data...");

                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            // Simulate potential API error
                            // if (Math.random() > 0.8) throw new Error("Simulated network error");
                            console.log("Data fetched (simulated)");
                            this.isLoading = false;
                            resolve(this.mangaData);
                        } catch (error) {
                            console.error("Error fetching manga data:", error);
                            this.isLoading = false;
                            reject(error);
                        }
                    }, 500);
                });
            }


            async loadMangaData() {
                if (this.isLoading) return;

                try {
                    const data = await this.fetchMangaData();

                    // 最初は表示に必要な最小限のデータだけを処理
                    this.contentTitle.textContent = data.title || 'Manga Viewer';
                    this.readingDirection = data.reading_direction || 'rtl';

                    // 章・エピソードのメタデータだけを初期化
                    this.episodeStructure = [];
                    if (data.frontMatter && data.frontMatter.length > 0) {
                        this.episodeStructure.push({
                            id: 'frontmatter',
                            title: '表紙・目次',
                            startPage: 0,
                            endPage: data.frontMatter.length - 1,
                            totalPages: data.frontMatter.length
                        });
                    }

                    let pageCount = data.frontMatter?.length || 0;
                    if (data.episodes && data.episodes.length > 0) {
                        data.episodes.forEach((episode, index) => {
                            if (episode.pages && episode.pages.length > 0) {
                                this.episodeStructure.push({
                                    id: episode.id || `episode${index + 1}`,
                                    title: episode.title || `第${index + 1}話`,
                                    startPage: pageCount,
                                    endPage: pageCount + episode.pages.length - 1,
                                    totalPages: episode.pages.length
                                });
                                pageCount += episode.pages.length;
                            }
                        });
                    }

                    // --- Process Data (Combine ALL pages) ---
                    let combinedPages = [...(data.frontMatter || [])];
                    if (data.episodes && data.episodes.length > 0) {
                        data.episodes.forEach(episode => {
                            if (episode.pages) {
                                combinedPages = combinedPages.concat(episode.pages);
                            }
                        });
                    } else {
                        throw new Error("有効なエピソードデータが見つかりません。");
                    }
                    this.allPages = combinedPages;
                    this.totalPages = this.allPages.length;


                    if (this.totalPages === 0) {
                        throw new Error("表示できるページがありません。");
                    }

                    // Update UI elements (Simplified Title)
                    this.pageSlider.max = this.totalPages;
                    this.pageSlider.min = 1;
                    this.pageSlider.value = this.currentPageIndex + 1;

                    this.loadBookmark(); // Load bookmark before loading the page

                    this.loadPage(this.currentPageIndex);
                    this.updatePageNumber();

                    this.loadingSpinner.style.display = 'none';

                } catch (error) {
                    console.error("Error processing manga data:", error);
                    this.showError(`データの読み込みまたは処理に失敗しました: ${error.message}`);
                    this.loadingSpinner.style.display = 'none';
                }
            }


            setupEventListeners() {
                // イベント委任の活用
                this.bottomOverlay.addEventListener('click', (e) => {
                    const target = e.target.closest('.ui-button');
                    if (!target) return;

                    if (target.id === 'prev-button') this.prevPage();
                    else if (target.id === 'next-button') this.nextPage();
                    else if (target.id === 'fullscreen-button') this.toggleFullscreen();
                    else if (target.id === 'episode-btn') this.showEpisodeList();
                });

                // Navigation zones (Click/Tap)
                this.prevZone.addEventListener('click', this.prevPage.bind(this));
                this.nextZone.addEventListener('click', this.nextPage.bind(this));
                this.centerZone.addEventListener('click', this.toggleUI.bind(this));

                // Slider
                this.pageSlider.addEventListener('input', this.onSliderInput.bind(this));
                this.pageSlider.addEventListener('change', this.onSliderChange.bind(this));

                // Retry button
                this.retryButton.addEventListener('click', this.retryLoad.bind(this));

                // タッチイベントのパッシブオプションを確実に設定
                const touchOptions = { passive: true };
                this.viewerContainer.addEventListener('touchstart', this.handleTouchStart.bind(this), touchOptions);
                // touchmoveはpreventDefaultが必要なためpassive: falseのまま
                this.viewerContainer.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.viewerContainer.addEventListener('touchend', this.handleTouchEnd.bind(this), touchOptions);
                this.viewerContainer.addEventListener('touchcancel', this.handleTouchCancel.bind(this), touchOptions);

                // Keyboard navigation
                document.addEventListener('keydown', this.handleKeyDown.bind(this));

                // Window resize event
                window.addEventListener('resize', this.handleResize.bind(this));

                // Fullscreen change event
                document.addEventListener('fullscreenchange', this.updateFullscreenIcon.bind(this));
                document.addEventListener('webkitfullscreenchange', this.updateFullscreenIcon.bind(this));
            }

            // Removed static userSettings object
            // In-memory bookmark store (replace with localStorage or server-side)
            static bookmarks = {};

            // Removed loadSavedSettings, saveSettings, updateSettingsUI

            showUI(autoHide = true) {
                this.viewerContainer.classList.add('show-ui');
                this.viewerContainer.classList.remove('ui-hidden');
                this.isUIVisible = true;
                this.clearUiHideTimeout();

                if (autoHide) {
                    this.scheduleUiHide();
                }
            }

            hideUI() {
                // Removed check for isSettingsVisible
                this.viewerContainer.classList.add('ui-hidden');
                this.isUIVisible = false;
                this.clearUiHideTimeout();
            }

            toggleUI() {
                // Simplified check
                if (this.isUIVisible) {
                    this.hideUI();
                } else {
                    this.showUI();
                }
            }

            showEpisodeList() {
                const episodeOverlay = document.getElementById('episode-overlay');
                const episodeList = document.getElementById('episode-list');

                // リストをクリア
                episodeList.innerHTML = '';

                // 表紙・目次へのリンク
                const coverItem = document.createElement('div');
                coverItem.className = 'episode-item';
                coverItem.textContent = '表紙・目次';
                coverItem.addEventListener('click', () => {
                    this.goToPage(0);
                    episodeOverlay.classList.remove('active');
                });
                episodeList.appendChild(coverItem);

                // 各エピソードへのリンク
                this.episodeStructure.forEach(episode => {
                    if (episode.id === 'frontmatter') return; // 表紙は既に追加済み

                    const episodeItem = document.createElement('div');
                    episodeItem.className = 'episode-item';

                    // 現在のエピソードを強調表示
                    if (this.currentPageIndex >= episode.startPage &&
                        this.currentPageIndex <= episode.endPage) {
                        episodeItem.classList.add('current');
                    }

                    episodeItem.textContent = episode.title;
                    episodeItem.addEventListener('click', () => {
                        this.goToPage(episode.startPage);
                        episodeOverlay.classList.remove('active');
                    });

                    episodeList.appendChild(episodeItem);
                });

                // オーバーレイを表示
                episodeOverlay.classList.add('active');

                // 閉じるボタン
                document.getElementById('close-episode-btn').addEventListener('click', () => {
                    episodeOverlay.classList.remove('active');
                });
            }

            scheduleUiHide() {
                this.clearUiHideTimeout();
                this.uiHideTimeout = setTimeout(() => {
                    // Removed check for isSettingsVisible
                    this.hideUI();
                }, 3000);
            }

            clearUiHideTimeout() {
                if (this.uiHideTimeout) {
                    clearTimeout(this.uiHideTimeout);
                    this.uiHideTimeout = null;
                }
            }

            // Removed toggleSettings, setPageMode, setFitMode, applyFitMode, setTheme, applyTheme

            toggleFullscreen() {
                if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                    const element = this.viewerContainer;
                    if (element.requestFullscreen) element.requestFullscreen();
                    else if (element.webkitRequestFullscreen) element.webkitRequestFullscreen();
                } else {
                    if (document.exitFullscreen) document.exitFullscreen();
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                }
            }

            updateFullscreenIcon() {
                const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
                if (this.fullscreenEnterIcon && this.fullscreenExitIcon) {
                    this.fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                    this.fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
                }
            }

            updatePageNumber() {
                if (this.totalPages === 0) {
                    this.pageNumber.textContent = "- / -";
                    this.pageSlider.value = 1;
                    this.pageSlider.max = 1;
                    this.prevButton.disabled = true;
                    this.nextButton.disabled = true;
                    this.prevZone.style.pointerEvents = 'none';
                    this.nextZone.style.pointerEvents = 'none';
                    return;
                }

                // DOMの変更をバッチ処理
                // パフォーマンスのため、リフローを引き起こす前に計算を完了
                const isFirstPage = this.currentPageIndex === 0;
                const isLastPage = this.currentPageIndex >= this.totalPages - 1;
                const displayedPage = this.currentPageIndex + 1;
                const pageNumberText = `${displayedPage} / ${this.totalPages}`;

                // DOMの更新をバッチで実行
                requestAnimationFrame(() => {
                    this.pageNumber.textContent = pageNumberText;
                    this.pageSlider.value = displayedPage;
                    this.prevButton.disabled = isFirstPage;
                    this.nextButton.disabled = isLastPage;
                    this.prevZone.style.pointerEvents = isFirstPage ? 'none' : 'auto';
                    this.nextZone.style.pointerEvents = isLastPage ? 'none' : 'auto';
                });
            }

            prevPage() {
                if (this.currentPageIndex > 0) {
                    this.goToPage(this.currentPageIndex - 1);
                }
                this.showUI();
            }

            nextPage() {
                // Simplified: always advance by 1 page index unit
                const increment = 1;
                if (this.currentPageIndex < this.totalPages - increment) {
                    this.goToPage(this.currentPageIndex + increment);
                }
                this.showUI();
            }

            goToPage(pageIndex) {
                const newIndex = Math.max(0, Math.min(pageIndex, this.totalPages - 1));
                if (newIndex === this.currentPageIndex && this.currentPage.src && this.currentPage.src !== "") {
                    console.log("Already on page", newIndex);
                    return;
                }

                this.currentPageIndex = newIndex;
                this.resetZoom();
                this.loadPage(this.currentPageIndex);
                this.updatePageNumber();
                this.saveBookmark();
                this.showUI();

                // 一定間隔でクリーンアップを実行
                if (!this.pageChangeCount) this.pageChangeCount = 0;
                if (this.pageChangeCount % 5 === 0) {
                    // メインスレッドをブロックしないようにセットタイムアウトで遅延実行
                    setTimeout(() => this.cleanupUnusedResources(), 500);
                }
                this.pageChangeCount++;
            }

            onSliderInput() {
                this.pageNumber.textContent = `${this.pageSlider.value} / ${this.totalPages}`;
                this.showUI(false);
                this.clearUiHideTimeout();
            }
            onSliderChange() {
                this.goToPage(parseInt(this.pageSlider.value) - 1);
                this.scheduleUiHide();
            }

            retryLoad() {
                this.errorMessage.style.display = 'none';
                this.loadPage(this.currentPageIndex);
            }

            saveBookmark() {
                if (!this.mangaData || !this.allPages.length) return;
                try {
                    // Use manga ID as the key for the overall bookmark
                    const key = `${this.mangaData.id}_bookmark`;
                    MangaViewer.bookmarks[key] = this.currentPageIndex;
                    // console.log(`Bookmark saved (in memory): ${key} = ${this.currentPageIndex}`);
                } catch (error) {
                    console.error('Error saving bookmark:', error);
                }
            }

            loadBookmark() {
                if (!this.mangaData) return;
                try {
                    // Use manga ID as the key
                    const key = `${this.mangaData.id}_bookmark`;
                    const savedIndex = MangaViewer.bookmarks[key];

                    if (savedIndex !== undefined && savedIndex >= 0 && savedIndex < this.totalPages) {
                        console.log(`Bookmark loaded (in memory): ${key} = ${savedIndex}`);
                        this.currentPageIndex = savedIndex;
                    } else {
                        this.currentPageIndex = 0; // Default to first page if no bookmark
                    }
                } catch (error) {
                    console.error('Error loading bookmark:', error);
                    this.currentPageIndex = 0;
                }
            }


            loadPage(pageIndex) {
                if (this.isLoading) return;
                this.isLoading = true;
                this.resetZoom();
                this.loadingSpinner.style.display = 'block';
                this.errorMessage.style.display = 'none';

                if (pageIndex < 0 || pageIndex >= this.totalPages) {
                    this.showError(`無効なページインデックス: ${pageIndex}`);
                    this.isLoading = false;
                    this.loadingSpinner.style.display = 'none';
                    return;
                }

                const pageData = this.allPages[pageIndex];
                if (!pageData || !pageData.image_url) {
                    this.showError(`ページ ${pageIndex + 1} のデータが見つかりません。`);
                    this.isLoading = false;
                    this.loadingSpinner.style.display = 'none';
                    return;
                }

                // 既に同じ画像がロードされている場合はスキップ
                if (this.currentPage.dataset.imageUrl === pageData.image_url) {
                    this.loadingSpinner.style.display = 'none';
                    this.isLoading = false;
                    return;
                }

                // Function to load the single image
                const loadImage = (imgElement, src) => {
                    return new Promise((resolve, reject) => {
                        if (!imgElement) return reject(new Error("Image element missing."));

                        const img = new Image();
                        img.onload = () => {
                            imgElement.src = src;
                            imgElement.style.backgroundColor = 'transparent';
                            imgElement.dataset.imageUrl = src; // 画像URLを要素に記録
                            resolve();
                        };
                        img.onerror = (err) => {
                            console.error(`Error loading image: ${src}`, err);
                            imgElement.style.backgroundColor = 'red';
                            reject(new Error(`画像 (${src.split('/').pop()}) の読み込み失敗`));
                        };
                        imgElement.src = ""; // Clear previous
                        imgElement.style.backgroundColor = '#333'; // Placeholder
                        img.src = src;
                    });
                };

                // Load the primary page
                loadImage(this.currentPage, pageData.image_url)
                    .then(() => {
                        this.preloadAdjacentPages(pageIndex);
                    })
                    .catch((error) => {
                        this.showError(error.message);
                    })
                    .finally(() => {
                        this.loadingSpinner.style.display = 'none';
                        this.isLoading = false;
                    });
            }

            // Removed updatePageDisplay (no longer needed for single page mode)

            preloadAdjacentPages(currentIndex) {
                // 読み込むページの優先順位付け
                const pagesToPreload = [];

                // 読み方向に基づいて、次のページを優先度高で追加
                if (this.readingDirection === 'rtl') {
                    // 右から左の場合、左側（前のインデックス）を先に
                    if (currentIndex > 0) pagesToPreload.push({ index: currentIndex - 1, priority: 'high' });
                    if (currentIndex + 1 < this.totalPages) pagesToPreload.push({ index: currentIndex + 1, priority: 'medium' });
                } else {
                    // 左から右の場合、右側（次のインデックス）を先に
                    if (currentIndex + 1 < this.totalPages) pagesToPreload.push({ index: currentIndex + 1, priority: 'high' });
                    if (currentIndex > 0) pagesToPreload.push({ index: currentIndex - 1, priority: 'medium' });
                }

                // さらに2ページ先も低優先度でプリロード
                if (this.readingDirection === 'rtl' && currentIndex > 1) {
                    pagesToPreload.push({ index: currentIndex - 2, priority: 'low' });
                } else if (this.readingDirection !== 'rtl' && currentIndex + 2 < this.totalPages) {
                    pagesToPreload.push({ index: currentIndex + 2, priority: 'low' });
                }

                // プリロード実行（優先度高いものから）
                pagesToPreload.forEach(({ index, priority }) => {
                    const page = this.allPages[index];
                    if (!page || !page.image_url) return;

                    const img = new Image();
                    // モダンブラウザのみサポート
                    if (priority === 'high' && 'fetchPriority' in HTMLImageElement.prototype) {
                        img.fetchPriority = 'high';
                    }
                    img.src = page.image_url;
                });
            }
            cleanupUnusedResources() {
                // 現在のページから離れているページの画像参照をクリア
                const currentImages = new Set();
                const currentPage = this.currentPageIndex;

                // 現在のページと隣接するページ（プリロード対象）だけを保持
                for (let i = Math.max(0, currentPage - 1); i <= Math.min(this.totalPages - 1, currentPage + 1); i++) {
                    if (this.allPages[i] && this.allPages[i].image_url) {
                        currentImages.add(this.allPages[i].image_url);
                    }
                }

                // ブラウザのメモリキャッシュは直接クリアできないため、
                // イメージオブジェクトの明示的な解放がベストエフォートとなります
                // 必要に応じてここに追加のクリーンアップロジックを実装できます
            }
            showError(message) {
                this.loadingSpinner.style.display = 'none';
                this.errorText.textContent = message;
                this.errorMessage.style.display = 'block';
                this.isLoading = false;
            }


            // --- Touch Event Handlers (largely unchanged, ensure no references to removed features) ---

            handleTouchStart(e) {
                this.showUI();
                this.clearUiHideTimeout();

                if (e.touches.length === 1) {
                    this.isZooming = false;
                    this.isPanning = this.scale > 1;
                    this.touchStartX = e.touches[0].clientX;
                    this.touchStartY = e.touches[0].clientY;
                    if (this.isPanning) {
                        this.panStartX = this.translateX;
                        this.panStartY = this.translateY;
                    }
                } else if (e.touches.length === 2) {
                    this.isZooming = true;
                    this.isPanning = false;
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    this.initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    this.initialScale = this.scale;
                    this.panStartX = this.translateX;
                    this.panStartY = this.translateY;
                    const rect = this.zoomContainer.getBoundingClientRect();
                    this.pinchCenterX = ((touch1.clientX + touch2.clientX) / 2) - rect.left;
                    this.pinchCenterY = ((touch1.clientY + touch2.clientY) / 2) - rect.top;
                }
            }

            handleTouchMove(e) {
                // 処理が必要ない場合は早期リターン
                if ((!this.isZooming && !this.isPanning) || e.touches.length === 0) return;

                if (this.isZooming && e.touches.length === 2) {
                    e.preventDefault();

                    // キャッシュを活用して計算を最適化
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );

                    if (this.initialDistance > 0) {
                        // 計算の簡略化と最適化
                        const scaleFactor = currentDistance / this.initialDistance;
                        this.scale = Math.max(1, Math.min(this.initialScale * scaleFactor, 3));

                        this.applyPanBoundaries();
                        this.updateZoom();
                    }
                } else if (this.isPanning && e.touches.length === 1) {
                    e.preventDefault();
                    const currentX = e.touches[0].clientX;
                    const currentY = e.touches[0].clientY;
                    const deltaX = currentX - this.touchStartX;
                    const deltaY = currentY - this.touchStartY;

                    this.translateX = this.panStartX + deltaX;
                    this.translateY = this.panStartY + deltaY;

                    this.applyPanBoundaries();
                    this.updateZoom();
                }
            }

            handleTouchEnd(e) {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - this.lastTapTime;
                let isDoubleTap = false;

                if (e.changedTouches.length === 1 && tapLength < 300 && tapLength > 0) {
                    isDoubleTap = true;
                    const rect = this.viewerContainer.getBoundingClientRect();
                    const tapX = e.changedTouches[0].clientX - rect.left;
                    const tapY = e.changedTouches[0].clientY - rect.top;

                    if (this.scale === 1) {
                        this.scale = 2;
                        // Center zoom towards tap point (approximate)
                        this.translateX = (this.viewerContainer.clientWidth / 2 - tapX) * (this.scale - 1) / this.scale;
                        this.translateY = (this.viewerContainer.clientHeight / 2 - tapY) * (this.scale - 1) / this.scale;
                    } else {
                        this.resetZoom();
                    }
                    this.applyPanBoundaries();
                    this.updateZoom();
                }
                this.lastTapTime = currentTime;

                if (!isDoubleTap && !this.isZooming && this.scale <= 1.05 && e.changedTouches.length === 1) {
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    const deltaX = touchEndX - this.touchStartX;
                    const deltaY = touchEndY - this.touchStartY;
                    const swipeThreshold = 50;
                    const verticalThreshold = 50;

                    if (Math.abs(deltaX) > swipeThreshold && Math.abs(deltaY) < verticalThreshold) {
                        if (this.readingDirection === 'rtl') {
                            if (deltaX > 0) this.prevPage(); else this.nextPage();
                        } else {
                            if (deltaX < 0) this.nextPage(); else this.prevPage();
                        }
                    }
                }

                if (this.isZooming && e.touches.length < 2) {
                    this.isZooming = false;
                    if (this.scale < 1.05) {
                        this.resetZoom();
                        this.updateZoom();
                    }
                }
                if (this.isPanning && e.touches.length === 0) {
                    this.isPanning = false;
                }

                this.scheduleUiHide();
            }

            handleTouchCancel(e) {
                console.log("Touch cancelled");
                this.isZooming = false;
                this.isPanning = false;
                this.initialDistance = 0;
                this.scheduleUiHide();
            }


            updateZoom() {
                // scale=1の場合とそれ以外でトランジションを切り替え
                const applyTransition = this.scale === 1 && this.translateX === 0 && this.translateY === 0;
                this.zoomContainer.style.transition = applyTransition ? 'transform 0.3s ease' : 'none';

                // transform3dを使用してハードウェアアクセラレーションを活用
                this.zoomContainer.style.transform = `translate3d(${this.translateX}px, ${this.translateY}px, 0) scale(${this.scale})`;
            }

            resetZoom() {
                if (this.scale !== 1 || this.translateX !== 0 || this.translateY !== 0) {
                    this.scale = 1;
                    this.translateX = 0;
                    this.translateY = 0;
                    this.updateZoom(); // This will now apply the transition
                }
            }

            applyPanBoundaries() {
                const containerWidth = this.viewerContainer.clientWidth;
                const containerHeight = this.viewerContainer.clientHeight;
                const contentWidth = containerWidth * this.scale;
                const contentHeight = containerHeight * this.scale;
                const maxTranslateX = Math.max(0, (contentWidth - containerWidth) / 2);
                const maxTranslateY = Math.max(0, (contentHeight - containerHeight) / 2);

                this.translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, this.translateX));
                this.translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, this.translateY));
            }


            handleKeyDown(e) {
                switch (e.key) {
                    case 'ArrowLeft':
                        if (this.readingDirection === 'rtl') this.nextPage();
                        else this.prevPage();
                        break;
                    case 'ArrowRight':
                        if (this.readingDirection === 'rtl') this.prevPage();
                        else this.nextPage();
                        break;
                    case ' ':
                        this.nextPage();
                        break;
                    case 'Escape':
                        // Removed settings toggle, only hide UI
                        if (this.isUIVisible) this.hideUI();
                        break;
                }
            }

            handleResize() {
                // Reset zoom on resize (fit mode is now handled by CSS)
                this.resetZoom();
                // No need to re-apply fit mode or update display specifically for resize anymore
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            if (!window.mangaViewerInstance) {
                window.mangaViewerInstance = new MangaViewer();
            }
        });
    </script>
</body>

</html>
