<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Commercial Manga Viewer</title>
    <style>
        :root {
            --primary-color: #4a6cf7;
            --secondary-color: #ff6b6b;
            /* Simplified: Defaulting to light theme variables */
            --background-color: #ffffff;
            --text-color: #333333;
            --overlay-background: rgba(0, 0, 0, 0.7);
            --overlay-text: #ffffff;
            --button-background: rgba(255, 255, 255, 0.2);
            --button-hover: rgba(255, 255, 255, 0.4);
            --slider-track: rgba(255, 255, 255, 0.3);
            --slider-thumb: #ffffff;
            --spinner-color: #ffffff;
            --error-color: #ff4d4d;
        }

        /* Optional: Keep dark theme styles if system preference detection is desired, */
        /* but remove the manual switching buttons/logic */
        @media (prefers-color-scheme: dark) {
            :root {
                --background-color: #121212;
                --text-color: #f1f1f1;
                --overlay-background: rgba(0, 0, 0, 0.8);
            }
        }


        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: fixed;
            touch-action: manipulation;
            /* Avoids zoom on double tap, etc. */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #viewer-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
        }

        #viewer-container:active {
            cursor: grabbing;
        }

        #zoom-container {
            width: 100%;
            height: 100%;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            transform-origin: center;
            /* 動的な変更時のみトランジションを適用する（JSで制御） */
            transition: none;
            /* ハードウェアアクセラレーションを有効化 */
            transform: translate3d(0, 0, 0);
            will-change: transform;
        }

        #manga-page-container {
            position: relative;
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .manga-page {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            /* Default fit mode */
            transform-origin: center;
            transition: opacity 0.3s ease;
            pointer-events: none;
            flex-shrink: 0;
            background-color: transparent;
            /* Use transparent bg by default */
            /* ハードウェアアクセラレーションを有効化 */
            transform: translateZ(0);
            will-change: transform, opacity;
        }

        /* Navigation zones */
        .nav-zone {
            position: absolute;
            height: 100%;
            width: 30%;
            top: 0;
            z-index: 10;
            /* background-color: rgba(255,0,0,0.1); */
            /* For debugging */
        }

        #prev-zone {
            left: 0;
            cursor: pointer;
        }

        #next-zone {
            right: 0;
            cursor: pointer;
        }

        #center-zone {
            left: 30%;
            width: 40%;
            cursor: pointer;
            /* background-color: rgba(0,255,0,0.1); */
            /* For debugging */
        }

        /* UI Overlays */
        .ui-overlay {
            position: absolute;
            left: 0;
            width: 100%;
            padding: 15px;
            color: var(--overlay-text);
            background-color: var(--overlay-background);
            z-index: 20;
            transition: transform 0.3s ease, opacity 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            /* ハードウェアアクセラレーションを有効化 */
            transform: translate3d(0, 0, 0);
            will-change: transform, opacity;
            opacity: 0;
            /* Start hidden */
        }

        .ui-overlay>* {
            pointer-events: auto;
        }

        #top-overlay {
            top: 0;
            transform: translateY(-100%);
        }

        #bottom-overlay {
            bottom: 0;
            transform: translateY(100%);
        }

        #viewer-container.show-ui .ui-overlay {
            /* Target overlays inside show-ui container */
            transform: translateY(0);
            opacity: 1;
        }

        /* Buttons and controls */
        .ui-button {
            background-color: var(--button-background);
            border: none;
            color: var(--overlay-text);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
            padding: 0;
            /* Ensure no extra padding */
        }

        .ui-button:hover,
        .ui-button:active {
            background-color: var(--button-hover);
        }

        .ui-button:disabled {
            opacity: 0.5;
            cursor: default;
            background-color: var(--button-background);
            /* Prevent hover effect */
        }


        .ui-button svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        /* Page slider */
        #page-slider-container {
            flex-grow: 1;
            margin: 0 15px;
            display: flex;
            align-items: center;
        }

        #page-slider {
            width: 100%;
            height: 8px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background: var(--slider-track);
            border-radius: 4px;
            outline: none;
        }

        #page-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
        }

        #page-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
            border: none;
        }

        /* Loading spinner */
        #loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--spinner-color);
            animation: spin 1s ease-in-out infinite;
            z-index: 40;
            display: none;
            /* Initially hidden */
            transform: translate(-50%, -50%);
            /* Ensure centering */
        }

        @keyframes spin {
            from {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Error message */
        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--error-color);
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            max-width: 80%;
            text-align: center;
            z-index: 40;
            display: none;
            /* Initially hidden */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        #retry-button {
            margin-top: 15px;
            padding: 8px 15px;
            background-color: white;
            color: var(--error-color);
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        #retry-button:hover {
            background-color: #eee;
        }

        /* Episode Overlay */
        #episode-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--overlay-background);
            z-index: 50;
            display: none;
            /* Changed from flex to none */
            justify-content: center;
            align-items: center;
            opacity: 0;
            /* Add opacity for transition */
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #episode-overlay.active {
            display: flex;
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            width: 80%;
            max-width: 500px;
            background-color: var(--background-color);
            color: var(--text-color);
            /* Ensure text color contrasts */
            border-radius: 8px;
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
            transform: scale(0.95);
            /* Add subtle scale effect */
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #episode-overlay.active .modal-content {
            transform: scale(1);
            opacity: 1;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(128, 128, 128, 0.2);
            /* Add separator */
            padding-bottom: 10px;
        }

        .modal-header h2 {
            margin: 0;
            /* Remove default margin */
        }


        #episode-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .episode-item {
            padding: 12px;
            background-color: rgba(128, 128, 128, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .episode-item:hover {
            background-color: rgba(128, 128, 128, 0.2);
        }

        .episode-item.current {
            border-left: 3px solid var(--primary-color);
            font-weight: bold;
            background-color: rgba(128, 128, 128, 0.15);
            /* Slightly different background */
        }

        #close-episode-btn {
            /* Style close button */
            background: none;
            border: none;
            font-size: 24px;
            line-height: 1;
            color: var(--text-color);
            opacity: 0.7;
            width: auto;
            /* Override default button size */
            height: auto;
        }

        #close-episode-btn:hover {
            opacity: 1;
            background: none;
            /* Override hover */
        }
    </style>
</head>
<body>
    <!-- Start with UI hidden, show after load -->
    <div id="viewer-container">
        <!-- Zoom container -->
        <div id="zoom-container">
            <!-- Manga page container (Simplified: Only one page element needed) -->
            <div id="manga-page-container">
                <!-- Set initial src to avoid broken image, or use placeholder -->
                <img alt="Manga page" class="manga-page" id="current-page" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"> <!-- Transparent 1x1 GIF -->
            </div>
        </div>
        <!-- Navigation zones -->
        <div class="nav-zone" id="prev-zone" aria-label="Previous Page"></div>
        <div class="nav-zone" id="center-zone" aria-label="Toggle UI"></div>
        <div class="nav-zone" id="next-zone" aria-label="Next Page"></div>
        <!-- Top UI overlay -->
        <div class="ui-overlay" id="top-overlay">
            <div id="content-title">Loading...</div>
            <div id="page-number">- / -</div>
        </div>
        <!-- Bottom UI overlay -->
        <div class="ui-overlay" id="bottom-overlay">
            <button class="ui-button" id="prev-button" aria-label="Previous Page" disabled> <!-- Start disabled -->
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M15.41,16.59L10.83,12l4.58-4.59L14,6l-6,6l6,6L15.41,16.59z"></path>
                </svg>
            </button>
            <div id="page-slider-container">
                <input type="range" min="1" max="1" value="1" id="page-slider" aria-label="Page Slider" disabled> <!-- Start disabled -->
            </div>
            <button class="ui-button" id="next-button" aria-label="Next Page" disabled> <!-- Start disabled -->
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M8.59,16.59L13.17,12L8.59,7.41L10,6l6,6l-6,6L8.59,16.59z"></path>
                </svg>
            </button>
            <button class="ui-button" id="fullscreen-button" aria-label="Toggle Fullscreen">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path id="fullscreen-enter-icon"
                        d="M7,14H5v5h5v-2H7V14z M5,10h2V7h3V5H5V10z M17,17h-3v2h5v-5h-2V17z M14,5v2h3v3h2V5H14z"></path>
                    <path id="fullscreen-exit-icon"
                        d="M5,16h3v3h2v-5H5V16z M8,5H5v5h2V7h3V5z M14,19h2v-3h3v-2h-5V19z M16,8h3V5h-2v3h-3V8z"
                        style="display: none;"></path>
                </svg>
            </button>
            <div id="episode-navigation">
                <button class="ui-button" id="episode-btn" aria-label="エピソード選択" disabled> <!-- Start disabled -->
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path
                            d="M3,13h2v-2H3V13z M3,17h2v-2H3V17z M3,9h2V7H3V9z M7,13h14v-2H7V13z M7,17h14v-2H7V17z M7,7v2h14V7H7z">
                        </path>
                    </svg>
                </button>
            </div>
        </div>
        <!-- Episode Selection Modal -->
        <div id="episode-overlay" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="episode-modal-title">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="episode-modal-title">エピソード選択</h2>
                    <button id="close-episode-btn" class="ui-button" aria-label="閉じる">×</button>
                </div>
                <div id="episode-list">
                    <!-- Episode items will be populated here -->
                </div>
            </div>
        </div>
        <!-- Loading spinner -->
        <div id="loading-spinner" aria-label="Loading" role="status"></div>
        <!-- Error message -->
        <div id="error-message" role="alert">
            <div id="error-text">読み込みに失敗しました。</div>
            <button id="retry-button">再試行</button>
        </div>
    </div>
    <script>
        // --- 定数の定義 ---
        const UI_HIDE_DELAY_MS = 3000;
        const DOUBLE_TAP_TIMEOUT_MS = 300;
        const SWIPE_THRESHOLD_PX = 50;
        const SWIPE_VERTICAL_THRESHOLD_PX = 75;
        const MAX_ZOOM_SCALE = 5;
        const DOUBLE_TAP_ZOOM_SCALE = 2;
        const PRELOAD_DEPTH = 2;
        const MIN_TAP_DURATION_MS = 50; // ダブルタップ判定時の最小タップ時間

        // Main viewer class
        class MangaViewer {
            constructor() {
                // 定数をプロパティとして設定
                this.UI_HIDE_DELAY_MS = UI_HIDE_DELAY_MS;
                this.DOUBLE_TAP_TIMEOUT_MS = DOUBLE_TAP_TIMEOUT_MS;
                this.SWIPE_THRESHOLD_PX = SWIPE_THRESHOLD_PX;
                this.SWIPE_VERTICAL_THRESHOLD_PX = SWIPE_VERTICAL_THRESHOLD_PX;
                this.MAX_ZOOM_SCALE = MAX_ZOOM_SCALE;
                this.DOUBLE_TAP_ZOOM_SCALE = DOUBLE_TAP_ZOOM_SCALE;
                this.PRELOAD_DEPTH = PRELOAD_DEPTH;
                this.MIN_TAP_DURATION_MS = MIN_TAP_DURATION_MS;

                // DOM elements - getElementでエラーチェックを行う
                try {
                    this.viewerContainer = this.getElement('viewer-container');
                    this.zoomContainer = this.getElement('zoom-container');
                    this.pageContainer = this.getElement('manga-page-container');
                    this.currentPage = this.getElement('current-page');
                    this.topOverlay = this.getElement('top-overlay');
                    this.bottomOverlay = this.getElement('bottom-overlay');
                    this.pageSlider = this.getElement('page-slider');
                    this.pageNumber = this.getElement('page-number');
                    this.contentTitle = this.getElement('content-title');
                    this.loadingSpinner = this.getElement('loading-spinner');
                    this.errorMessage = this.getElement('error-message');
                    this.errorText = this.getElement('error-text');
                    this.retryButton = this.getElement('retry-button');
                    this.episodeOverlay = this.getElement('episode-overlay');
                    this.episodeList = this.getElement('episode-list');
                    this.closeEpisodeButton = this.getElement('close-episode-btn');
                    this.prevZone = this.getElement('prev-zone');
                    this.nextZone = this.getElement('next-zone');
                    this.centerZone = this.getElement('center-zone');
                    this.prevButton = this.getElement('prev-button');
                    this.nextButton = this.getElement('next-button');
                    this.fullscreenButton = this.getElement('fullscreen-button');
                    this.fullscreenEnterIcon = this.getElement('fullscreen-enter-icon');
                    this.fullscreenExitIcon = this.getElement('fullscreen-exit-icon');
                    this.episodeButton = this.getElement('episode-btn');
                } catch (error) {
                    console.error("初期化エラー:", error);
                    // エラーメッセージを表示する試み（ただし、errorMessage要素自体がない可能性もある）
                    try {
                        const errorDiv = document.getElementById('error-message') || document.createElement('div');
                        errorDiv.id = 'init-error-fallback'; // Avoid conflict if error-message exists but is broken
                        // --- TEMPLATE LITERAL FIX ---
                        errorDiv.textContent = `ビューアの初期化に失敗しました: ${error.message}。ページをリロードしてください。`;
                        errorDiv.style.display = 'block';
                        errorDiv.style.position = 'fixed';
                        errorDiv.style.top = '50%';
                        errorDiv.style.left = '50%';
                        errorDiv.style.transform = 'translate(-50%, -50%)';
                        errorDiv.style.backgroundColor = 'var(--error-color, #ff4d4d)'; // Use CSS var if available
                        errorDiv.style.color = 'white';
                        errorDiv.style.padding = '20px';
                        errorDiv.style.borderRadius = '5px';
                        errorDiv.style.zIndex = '1000';
                        errorDiv.style.textAlign = 'center';
                        if (!document.getElementById(errorDiv.id)) {
                            document.body.appendChild(errorDiv);
                        }
                    } catch (displayError) {
                        console.error("フォールバックエラー表示失敗:", displayError);
                    }
                    return; // Stop initialization
                }

                // State variables
                this.currentPageIndex = 0;
                this.totalPages = 0;
                this.allPages = [];
                this.episodeStructure = [];
                this.mangaData = null;
                this.readingDirection = 'rtl'; // Default
                this.isUIVisible = false;
                this.uiHideTimeout = null;
                this.isLoading = false;
                this.isInitialized = false;
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.panStartX = 0;
                this.panStartY = 0;
                this.lastTapTime = 0;
                this.scale = 1;
                this.translateX = 0;
                this.translateY = 0;
                this.initialDistance = 0;
                this.isZooming = false;
                this.isPanning = false;
                this.pinchCenterX = 0;
                this.pinchCenterY = 0;
                this.initialScale = 1;
                this.activePointers = new Map();

                // --- Mock Manga Data --- (Keep for standalone testing)
                this.mockMangaData = {
                    id: 'manga123',
                    title: 'KARMA',
                    frontMatter: [
                        { page_number: 1, image_url: 'i_001.jpg', type: 'cover' },
                        { page_number: 2, image_url: 'i_002.jpg', type: 'contents' }
                    ],
                    episodes: [
                        { id: 'episode1', title: '第1話', pages: [{ page_number: 3, image_url: 'i_003.jpg' }, { page_number: 4, image_url: 'i_004.jpg' }, { page_number: 5, image_url: 'i_005.jpg' }, { page_number: 6, image_url: 'i_006.jpg' }, { page_number: 7, image_url: 'i_007.jpg' }, { page_number: 8, image_url: 'i_008.jpg' }, { page_number: 9, image_url: 'i_009.jpg' }, { page_number: 10, image_url: 'i_010.jpg' }, { page_number: 11, image_url: 'i_011.jpg' }, { page_number: 12, image_url: 'i_012.jpg' }, { page_number: 13, image_url: 'i_013.jpg' }] },
                        { id: 'episode2', title: '第2話', pages: [{ page_number: 14, image_url: 'i_014.jpg' }, { page_number: 15, image_url: 'i_015.jpg' }, { page_number: 16, image_url: 'i_016.jpg' }, { page_number: 17, image_url: 'i_017.jpg' }, { page_number: 18, image_url: 'i_018.jpg' }, { page_number: 19, image_url: 'i_019.jpg' }, { page_number: 20, image_url: 'i_020.jpg' }, { page_number: 21, image_url: 'i_021.jpg' }, { page_number: 22, image_url: 'i_022.jpg' }] },
                        { id: 'episode3', title: '第3話', pages: [{ page_number: 23, image_url: 'i_023.jpg' }, { page_number: 24, image_url: 'i_024.jpg' }, { page_number: 25, image_url: 'i_025.jpg' }, { page_number: 26, image_url: 'i_026.jpg' }, { page_number: 27, image_url: 'i_027.jpg' }, { page_number: 28, image_url: 'i_028.jpg' }, { page_number: 29, image_url: 'i_029.jpg' }, { page_number: 30, image_url: 'i_030.jpg' }, { page_number: 31, image_url: 'i_031.jpg' }] },
                        { id: 'episode4', title: '第4話', pages: [{ page_number: 32, image_url: 'i_032.jpg' }, { page_number: 33, image_url: 'i_033.jpg' }, { page_number: 34, image_url: 'i_034.jpg' }, { page_number: 35, image_url: 'i_035.jpg' }, { page_number: 36, image_url: 'i_036.jpg' }, { page_number: 37, image_url: 'i_037.jpg' }, { page_number: 38, image_url: 'i_038.jpg' }, { page_number: 39, image_url: 'i_039.jpg' }, { page_number: 40, image_url: 'i_040.jpg' }] },
                        { id: 'episode5', title: '第5話', pages: [{ page_number: 41, image_url: 'i_041.jpg' }, { page_number: 42, image_url: 'i_042.jpg' }, { page_number: 43, image_url: 'i_043.jpg' }, { page_number: 44, image_url: 'i_044.jpg' }, { page_number: 45, image_url: 'i_045.jpg' }, { page_number: 46, image_url: 'i_046.jpg' }, { page_number: 47, image_url: 'i_047.jpg' }, { page_number: 48, image_url: 'i_048.jpg' }] }
                    ],
                    reading_direction: 'rtl' // Can be 'rtl' or 'ltr'
                };
                // --- End Mock Data ---

                // init() is called from the DOMContentLoaded listener
            }

            getElement(id) {
                const element = document.getElementById(id);
                if (!element) {
                    // Throw an error for missing required elements
                    // --- TEMPLATE LITERAL FIX ---
                    throw new Error(`Required DOM element not found (ID: ${id})`);
                }
                return element;
            }

            async init() {
                // Prevent double initialization
                if (this.isInitialized) return;

                console.log("Viewer initialization started...");
                this.setupEventListeners();
                this.resetZoom();
                this.updateFullscreenIcon();

                try {
                    // Wait for manga data to load and process
                    await this.loadMangaData();
                    // isInitialized is set within loadMangaData on success
                    console.log("Viewer initialization completed.");
                } catch (error) {
                    console.error("Initialization failed:", error);
                    // Error is shown by loadMangaData or constructor fallback
                    // UI controls are disabled within loadMangaData on failure
                }
            }

            setupEventListeners() {
                // Use event delegation where possible
                this.bottomOverlay.addEventListener('click', (e) => {
                    if (!this.isInitialized) return; // Prevent actions before init
                    const target = e.target.closest('.ui-button');
                    if (!target || target.disabled) return;

                    // Use nextPage/prevPage which handle RTL logic
                    if (target.id === 'prev-button') this.prevPage();
                    else if (target.id === 'next-button') this.nextPage();
                    else if (target.id === 'fullscreen-button') this.toggleFullscreen();
                    else if (target.id === 'episode-btn') this.showEpisodeList();
                });

                // Navigation zones (Click/Tap) - Use nextPage/prevPage
                this.prevZone.addEventListener('click', (e) => { if (this.isInitialized) this.prevPage(); });
                this.nextZone.addEventListener('click', (e) => { if (this.isInitialized) this.nextPage(); });
                this.centerZone.addEventListener('click', (e) => { if (this.isInitialized) this.toggleUI(); });

                // Slider
                this.pageSlider.addEventListener('input', this.onSliderInput.bind(this));
                this.pageSlider.addEventListener('change', this.onSliderChange.bind(this));

                // Retry button
                this.retryButton.addEventListener('click', this.retryLoad.bind(this));

                // Episode modal close button
                this.closeEpisodeButton.addEventListener('click', this.hideEpisodeList.bind(this));
                // Close modal if clicking outside the content
                this.episodeOverlay.addEventListener('click', (e) => {
                    if (e.target === this.episodeOverlay) { // Clicked on the backdrop
                        this.hideEpisodeList();
                    }
                });

                // Pointer events for touch, mouse, pen
                this.viewerContainer.addEventListener('pointerdown', this.handlePointerDown.bind(this));
                this.viewerContainer.addEventListener('pointermove', this.handlePointerMove.bind(this), { passive: false }); // Need preventDefault
                this.viewerContainer.addEventListener('pointerup', this.handlePointerEnd.bind(this));
                this.viewerContainer.addEventListener('pointercancel', this.handlePointerCancel.bind(this)); // Handle interruptions

                // Keyboard navigation
                document.addEventListener('keydown', this.handleKeyDown.bind(this));

                // Window resize event
                window.addEventListener('resize', this.handleResize.bind(this));

                // Fullscreen change event
                document.addEventListener('fullscreenchange', this.updateFullscreenIcon.bind(this));
                document.addEventListener('webkitfullscreenchange', this.updateFullscreenIcon.bind(this)); // Safari/iOS
            }

            async fetchMangaData() {
                // isLoading is set by the caller (loadMangaData)
                this.loadingSpinner.style.display = 'block';
                this.errorMessage.style.display = 'none';
                console.log("Fetching manga data (simulated)...");

                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            // Simulate potential API error
                            // if (Math.random() > 0.8) throw new Error("Simulated network error");
                            console.log("Data fetched (simulated)");
                            resolve(this.mockMangaData); // Use mock data
                        } catch (error) {
                            console.error("Error fetching manga data:", error);
                            reject(error);
                        } finally {
                            // isLoading/Spinner managed by the caller
                        }
                    }, 500); // Simulate network delay
                });
            }

            async loadMangaData() {
                if (this.isLoading) return;
                this.isLoading = true;
                this.loadingSpinner.style.display = 'block';
                this.errorMessage.style.display = 'none';
                this.isInitialized = false;

                try {
                    const data = await this.fetchMangaData();
                    this.mangaData = data;

                    this.contentTitle.textContent = data.title || 'Manga Viewer';
                    this.readingDirection = data.reading_direction === 'ltr' ? 'ltr' : 'rtl';
                    console.log("Reading Direction set to:", this.readingDirection);

                    // --- Process episodes and pages ---
                    this.episodeStructure = [];
                    let combinedPages = [];
                    let pageCount = 0;

                    if (data.frontMatter && Array.isArray(data.frontMatter) && data.frontMatter.length > 0) {
                        const fmStart = pageCount;
                        const fmEnd = fmStart + data.frontMatter.length - 1;
                        this.episodeStructure.push({
                            id: 'frontmatter',
                            title: '表紙・目次',
                            startPage: fmStart,
                            endPage: fmEnd,
                            totalPages: data.frontMatter.length
                        });
                        combinedPages = combinedPages.concat(data.frontMatter.map((p, i) => ({ ...p, index: fmStart + i })));
                        pageCount += data.frontMatter.length;
                    }

                    if (data.episodes && Array.isArray(data.episodes) && data.episodes.length > 0) {
                        data.episodes.forEach((episode, index) => {
                            if (episode.pages && Array.isArray(episode.pages) && episode.pages.length > 0) {
                                const epStart = pageCount;
                                const epEnd = epStart + episode.pages.length - 1;
                                this.episodeStructure.push({
                                    id: episode.id || `episode${index + 1}`, // --- TEMPLATE LITERAL FIX ---
                                    title: episode.title || `第${index + 1}話`, // --- TEMPLATE LITERAL FIX ---
                                    startPage: epStart,
                                    endPage: epEnd,
                                    totalPages: episode.pages.length
                                });
                                combinedPages = combinedPages.concat(episode.pages.map((p, i) => ({ ...p, index: epStart + i })));
                                pageCount += episode.pages.length;
                            }
                        });
                    }
                    // --- End Processing ---

                    this.allPages = combinedPages;
                    this.totalPages = this.allPages.length;

                    if (this.totalPages === 0) {
                        throw new Error("No pages available to display.");
                    }

                    this.pageSlider.max = this.totalPages;
                    this.pageSlider.min = 1;
                    this.pageSlider.disabled = false;
                    this.episodeButton.disabled = this.episodeStructure.length <= 1;

                    this.loadBookmark();
                    await this.loadPage(this.currentPageIndex);

                    this.isInitialized = true;
                    this.loadingSpinner.style.display = 'none';
                    this.updatePageNumber();
                    this.showUI();

                } catch (error) {
                    console.error("Error processing manga data:", error);
                    // --- TEMPLATE LITERAL FIX ---
                    this.showError(`Failed to load or process data: ${error.message}`);
                    this.pageSlider.disabled = true;
                    this.episodeButton.disabled = true;
                    this.isInitialized = false;
                    throw error;
                } finally {
                    this.isLoading = false;
                    this.loadingSpinner.style.display = 'none';
                }
            }

            // --- UI Visibility ---
            showUI(autoHide = true) {
                if (!this.isInitialized) return;
                this.viewerContainer.classList.add('show-ui');
                this.isUIVisible = true;
                this.clearUiHideTimeout();
                if (autoHide) {
                    this.scheduleUiHide();
                }
            }

            hideUI() {
                if (this.episodeOverlay.classList.contains('active')) return;
                this.viewerContainer.classList.remove('show-ui');
                this.isUIVisible = false;
                this.clearUiHideTimeout();
            }

            toggleUI(forceShow = false) {
                if (forceShow) { this.showUI(); }
                else if (this.isUIVisible) { this.hideUI(); }
                else { this.showUI(); }
            }

            scheduleUiHide() {
                this.clearUiHideTimeout();
                this.uiHideTimeout = setTimeout(() => {
                    this.hideUI();
                }, this.UI_HIDE_DELAY_MS);
            }

            clearUiHideTimeout() {
                if (this.uiHideTimeout) {
                    clearTimeout(this.uiHideTimeout);
                    this.uiHideTimeout = null;
                }
            }

            // --- Episode List ---
            showEpisodeList() {
                if (!this.episodeStructure || this.episodeStructure.length === 0 || !this.isInitialized) return;

                this.episodeList.innerHTML = '';
                let currentEpisodeItem = null;

                this.episodeStructure.forEach(episode => {
                    const episodeItem = document.createElement('div');
                    episodeItem.className = 'episode-item';
                    episodeItem.textContent = episode.title;
                    episodeItem.dataset.startPage = episode.startPage;
                    episodeItem.setAttribute('role', 'button');
                    episodeItem.tabIndex = 0;

                    if (this.currentPageIndex >= episode.startPage && this.currentPageIndex <= episode.endPage) {
                        episodeItem.classList.add('current');
                        episodeItem.setAttribute('aria-current', 'true');
                        currentEpisodeItem = episodeItem;
                    }

                    const selectEpisode = () => {
                        const targetPage = parseInt(episodeItem.dataset.startPage, 10);
                        this.goToPage(targetPage);
                        this.hideEpisodeList();
                    };

                    episodeItem.addEventListener('click', selectEpisode);
                    episodeItem.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            selectEpisode();
                        }
                    });

                    this.episodeList.appendChild(episodeItem);
                });

                this.episodeOverlay.classList.add('active');
                this.clearUiHideTimeout();

                requestAnimationFrame(() => {
                    if (currentEpisodeItem) { currentEpisodeItem.focus(); }
                    else { this.closeEpisodeButton.focus(); }
                });
            }

            hideEpisodeList() {
                this.episodeOverlay.classList.remove('active');
                this.scheduleUiHide();
            }

            // --- Fullscreen ---
            toggleFullscreen() {
                if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                    const element = document.documentElement;
                    // --- TEMPLATE LITERAL FIX (within error messages) ---
                    if (element.requestFullscreen) element.requestFullscreen().catch(err => console.error(`Fullscreen request failed: ${err.message}`));
                    else if (element.webkitRequestFullscreen) element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                } else {
                    // --- TEMPLATE LITERAL FIX (within error messages) ---
                    if (document.exitFullscreen) document.exitFullscreen().catch(err => console.error(`Exit Fullscreen failed: ${err.message}`));
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                }
            }

            updateFullscreenIcon() {
                const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
                if (this.fullscreenEnterIcon && this.fullscreenExitIcon) {
                    this.fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                    this.fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
                    this.fullscreenButton.setAttribute('aria-label', isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen');
                }
            }

            // --- Page Navigation (RTL Handled) ---
            prevPage() {
                if (!this.isInitialized || this.isLoading) return;
                const targetIndex = this.readingDirection === 'rtl'
                    ? this.currentPageIndex + 1 : this.currentPageIndex - 1;
                if (targetIndex >= 0 && targetIndex < this.totalPages) {
                    this.goToPage(targetIndex);
                    this.showUI();
                } else {
                    console.log("Already at the boundary (prevPage)");
                }
            }

            nextPage() {
                if (!this.isInitialized || this.isLoading) return;
                const targetIndex = this.readingDirection === 'rtl'
                    ? this.currentPageIndex - 1 : this.currentPageIndex + 1;
                if (targetIndex >= 0 && targetIndex < this.totalPages) {
                    this.goToPage(targetIndex);
                    this.showUI();
                } else {
                    console.log("Already at the boundary (nextPage)");
                }
            }

            goToPage(pageIndex) {
                const newIndex = Math.max(0, Math.min(pageIndex, this.totalPages - 1));

                if ((newIndex === this.currentPageIndex && this.isInitialized && this.currentPage.dataset.imageUrl !== 'error') || this.isLoading) {
                    if (this.isLoading) console.log("Page load in progress, navigation skipped.");
                    else console.log("Already on page", newIndex + 1);
                    return;
                }

                // --- TEMPLATE LITERAL FIX ---
                console.log(`Navigating to page index ${newIndex} (Page ${newIndex + 1})`);
                this.currentPageIndex = newIndex;
                this.resetZoom();

                this.loadPage(this.currentPageIndex)
                    .then(() => {
                        // --- TEMPLATE LITERAL FIX ---
                        console.log(`Page ${this.currentPageIndex + 1} load successful (or already loaded). Updating UI.`);
                    })
                    .catch(err => {
                        // --- TEMPLATE LITERAL FIX ---
                        console.warn(`goToPage: loadPage failed for index ${this.currentPageIndex}. Error: ${err.message}`);
                    })
                    .finally(() => {
                        this.updatePageNumber();
                        this.saveBookmark();
                    });

                this.showUI();
            }

            onSliderInput() {
                if (!this.isInitialized) return;
                const sliderValue = parseInt(this.pageSlider.value, 10);
                // --- TEMPLATE LITERAL FIX ---
                this.pageNumber.textContent = `${sliderValue} / ${this.totalPages}`;
                // --- TEMPLATE LITERAL FIX ---
                this.pageSlider.setAttribute('aria-valuetext', `Page ${sliderValue} of ${this.totalPages}`);
                this.showUI(false);
                this.clearUiHideTimeout();
            }

            onSliderChange() {
                if (!this.isInitialized) return;
                const targetPage = parseInt(this.pageSlider.value) - 1;
                this.goToPage(targetPage);
                this.scheduleUiHide();
            }

            retryLoad() {
                this.errorMessage.style.display = 'none';
                if (this.mangaData && this.isInitialized) {
                    // --- TEMPLATE LITERAL FIX ---
                    console.log(`Retrying load for page index ${this.currentPageIndex}`);
                    this.loadPage(this.currentPageIndex);
                } else {
                    console.log("Retrying initial data load...");
                    this.init().catch(err => console.error("Retry initialization failed:", err));
                }
            }

            // --- Bookmarking (Using localStorage) ---
            saveBookmark() {
                if (!this.mangaData || !this.mangaData.id || !this.allPages.length || !this.isInitialized) {
                    return;
                }
                try {
                    // --- TEMPLATE LITERAL FIX ---
                    const key = `mangaViewer_${this.mangaData.id}_bookmark`;
                    localStorage.setItem(key, this.currentPageIndex.toString());
                } catch (error) {
                    console.error('Error saving bookmark to localStorage:', error);
                }
            }

            loadBookmark() {
                if (!this.mangaData || !this.mangaData.id || this.totalPages === 0) {
                    this.currentPageIndex = 0;
                    return;
                };
                try {
                    // --- TEMPLATE LITERAL FIX ---
                    const key = `mangaViewer_${this.mangaData.id}_bookmark`;
                    const savedIndexStr = localStorage.getItem(key);
                    if (savedIndexStr !== null) {
                        const savedIndex = parseInt(savedIndexStr, 10);
                        if (!isNaN(savedIndex) && savedIndex >= 0 && savedIndex < this.totalPages) {
                            // --- TEMPLATE LITERAL FIX ---
                            console.log(`Bookmark loaded: ${key} = ${savedIndex}`);
                            this.currentPageIndex = savedIndex;
                            return;
                        } else {
                            // --- TEMPLATE LITERAL FIX ---
                            console.warn(`Invalid bookmark value found: ${savedIndexStr}. Removing.`);
                            localStorage.removeItem(key);
                        }
                    } else {
                         // console.log(`No bookmark found for key: ${key}`);
                    }
                    this.currentPageIndex = 0;
                } catch (error) {
                    console.error('Error loading bookmark from localStorage:', error);
                    this.currentPageIndex = 0;
                }
            }

            // --- Page Number Update (ARIA + RTL Buttons) ---
            updatePageNumber() {
                if (!this.isInitialized) {
                    this.pageNumber.textContent = "- / -";
                    if (this.pageSlider) { /* Guard against null */
                        this.pageSlider.value = 1;
                        this.pageSlider.max = 1;
                        this.pageSlider.disabled = true;
                        this.pageSlider.removeAttribute('aria-valuetext');
                    }
                    if(this.prevButton) this.prevButton.disabled = true; /* Guard against null */
                    if(this.nextButton) this.nextButton.disabled = true; /* Guard against null */
                    if(this.prevZone) this.prevZone.style.pointerEvents = 'none'; /* Guard against null */
                    if(this.nextZone) this.nextZone.style.pointerEvents = 'none'; /* Guard against null */
                    return;
                }

                const displayedPage = this.currentPageIndex + 1;
                // --- TEMPLATE LITERAL FIX ---
                const pageNumberText = `${displayedPage} / ${this.totalPages}`;
                const isFirstPage = this.currentPageIndex === 0;
                const isLastPage = this.currentPageIndex >= this.totalPages - 1;

                const disablePrevBtn = (this.readingDirection === 'rtl') ? isLastPage : isFirstPage;
                const disableNextBtn = (this.readingDirection === 'rtl') ? isFirstPage : isLastPage;

                const prevLabel = this.readingDirection === 'rtl' ? '次のページ' : '前のページ';
                const nextLabel = this.readingDirection === 'rtl' ? '前のページ' : '次のページ';

                requestAnimationFrame(() => {
                    if (this.pageNumber.textContent !== pageNumberText) {
                        this.pageNumber.textContent = pageNumberText;
                    }
                    if (this.pageSlider && parseInt(this.pageSlider.value) !== displayedPage) {
                        this.pageSlider.value = displayedPage;
                    }
                    if (this.pageSlider) {
                        // --- TEMPLATE LITERAL FIX ---
                        this.pageSlider.setAttribute('aria-valuetext', `ページ ${displayedPage} / ${this.totalPages}`);
                    }
                    if (this.prevButton) {
                        this.prevButton.disabled = disablePrevBtn;
                        this.prevButton.setAttribute('aria-label', prevLabel);
                    }
                    if (this.nextButton) {
                        this.nextButton.disabled = disableNextBtn;
                        this.nextButton.setAttribute('aria-label', nextLabel);
                    }
                    if (this.prevZone) {
                        this.prevZone.style.pointerEvents = disablePrevBtn ? 'none' : 'auto';
                        this.prevZone.setAttribute('aria-label', prevLabel);
                    }
                    if (this.nextZone) {
                        this.nextZone.style.pointerEvents = disableNextBtn ? 'none' : 'auto';
                        this.nextZone.setAttribute('aria-label', nextLabel);
                    }
                });
            }

            // --- Page Loading and Preloading (RTL Handled) ---
            async loadPage(pageIndex) {
                if (pageIndex < 0 || pageIndex >= this.totalPages) {
                    // --- TEMPLATE LITERAL FIX ---
                    this.showError(`Invalid page index: ${pageIndex + 1}`);
                    // --- TEMPLATE LITERAL FIX ---
                    throw new Error(`Invalid page index: ${pageIndex}`);
                }
                const pageData = this.allPages[pageIndex];
                if (!pageData || !pageData.image_url) {
                    // --- TEMPLATE LITERAL FIX ---
                    this.showError(`Page data not found for page ${pageIndex + 1}.`);
                    // --- TEMPLATE LITERAL FIX ---
                    throw new Error(`Missing page data for index ${pageIndex}`);
                }

                if (this.currentPage.dataset.imageUrl === pageData.image_url && this.currentPage.dataset.imageUrl !== 'error') {
                    console.log("Image already loaded:", pageData.image_url);
                    this.isLoading = false;
                    this.loadingSpinner.style.display = 'none';
                    return;
                }

                // --- TEMPLATE LITERAL FIX ---
                console.log(`Loading image for page index ${pageIndex}: ${pageData.image_url}`);
                this.isLoading = true;
                this.loadingSpinner.style.display = 'block';
                this.errorMessage.style.display = 'none';

                try {
                    await this.loadImageWithPromise(this.currentPage, pageData.image_url);
                    // --- TEMPLATE LITERAL FIX ---
                    console.log(`Successfully loaded ${pageData.image_url}`);
                    this.preloadAdjacentPages(pageIndex);
                } catch (error) {
                     // --- TEMPLATE LITERAL FIX ---
                    console.error(`Failed to load image for page index ${pageIndex}: ${error.message}`);
                    this.showError(error.message);
                    throw error;
                } finally {
                    this.isLoading = false;
                    this.loadingSpinner.style.display = 'none';
                }
            }

            loadImageWithPromise(imgElement, src) {
                return new Promise((resolve, reject) => {
                    if (!imgElement) {
                        return reject(new Error("Target image element is missing."));
                    }
                    const img = new Image();
                    img.onload = () => {
                        // --- TEMPLATE LITERAL FIX ---
                        console.log(`Image loaded in background: ${src}`);
                        imgElement.src = src;
                        imgElement.style.backgroundColor = 'transparent';
                        imgElement.dataset.imageUrl = src;
                        imgElement.removeAttribute('data-load-error');
                        resolve();
                    };
                    img.onerror = (event) => {
                        const errorDetail = typeof event === 'string' ? event : (event && event.type ? event.type : 'unknown');
                        // --- TEMPLATE LITERAL FIX ---
                        console.error(`Error loading image: ${src}`, errorDetail);
                        imgElement.style.backgroundColor = 'var(--error-color, #500)';
                        imgElement.dataset.imageUrl = 'error';
                        imgElement.setAttribute('data-load-error', 'true');
                        let filename = 'file';
                        try { filename = new URL(src).pathname.split('/').pop() || 'file'; } catch (e) {}
                        // --- TEMPLATE LITERAL FIX ---
                        reject(new Error(`Image (${filename}) failed to load.`));
                    };

                    if (!imgElement.src || imgElement.src.startsWith('data:') || imgElement.dataset.imageUrl === 'error') {
                        imgElement.style.backgroundColor = '#333';
                        imgElement.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                    }
                    // --- TEMPLATE LITERAL FIX ---
                    console.log(`Starting background load for: ${src}`);
                    img.src = src;
                });
            }

            preloadAdjacentPages(currentIndex) {
                const pagesToPreload = new Set();
                for (let i = 1; i <= this.PRELOAD_DEPTH; i++) {
                    const nextPageIndex = (this.readingDirection === 'rtl') ? currentIndex - i : currentIndex + i;
                    if (nextPageIndex >= 0 && nextPageIndex < this.totalPages) {
                        pagesToPreload.add(nextPageIndex);
                    }
                    const prevPageIndex = (this.readingDirection === 'rtl') ? currentIndex + i : currentIndex - i;
                    if (prevPageIndex >= 0 && prevPageIndex < this.totalPages) {
                        pagesToPreload.add(prevPageIndex);
                    }
                }
                if (pagesToPreload.size > 0) {
                    pagesToPreload.forEach(index => {
                        const page = this.allPages[index];
                        if (page && page.image_url) {
                            const img = new Image();
                            if ('loading' in HTMLImageElement.prototype) {
                                img.loading = 'lazy';
                            }
                            img.src = page.image_url;
                        }
                    });
                }
            }

            showError(message) {
                console.error("Displaying error:", message);
                this.loadingSpinner.style.display = 'none';
                this.errorText.textContent = message;
                this.errorMessage.style.display = 'block';
                this.isLoading = false;
            }

            // --- Pointer Event Handlers (RTL Swipe Handled, Constants Used) ---
            handlePointerDown(e) {
                if (e.button !== 0 || !this.isInitialized) return;
                this.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, startTime: Date.now() });
                try { e.target.setPointerCapture(e.pointerId); }
                catch (err) { console.warn("Failed to capture pointer:", err.message); }
                this.showUI();
                this.clearUiHideTimeout();
                if (this.activePointers.size === 1) {
                    this.isZooming = false;
                    this.isPanning = this.scale > 1;
                    this.touchStartX = e.clientX;
                    this.touchStartY = e.clientY;
                    if (this.isPanning) {
                        this.panStartX = this.translateX;
                        this.panStartY = this.translateY;
                        this.viewerContainer.style.cursor = 'grabbing';
                    } else { this.viewerContainer.style.cursor = 'grab'; }
                } else if (this.activePointers.size === 2) {
                    this.isZooming = true; this.isPanning = false;
                    const pointers = Array.from(this.activePointers.values());
                    this.initialDistance = Math.hypot(pointers[1].x - pointers[0].x, pointers[1].y - pointers[0].y);
                    this.initialScale = this.scale;
                    const rect = this.zoomContainer.getBoundingClientRect();
                    this.pinchCenterX = ((pointers[0].x + pointers[1].x) / 2) - rect.left;
                    this.pinchCenterY = ((pointers[0].y + pointers[1].y) / 2) - rect.top;
                }
            }

            handlePointerMove(e) {
                if (!this.activePointers.has(e.pointerId) || !this.isInitialized) return;
                const currentPointer = this.activePointers.get(e.pointerId);
                if (currentPointer) { currentPointer.x = e.clientX; currentPointer.y = e.clientY; }
                if (this.isZooming && this.activePointers.size >= 2) {
                    e.preventDefault();
                    const pointers = Array.from(this.activePointers.values());
                    const currentDistance = Math.hypot(pointers[1].x - pointers[0].x, pointers[1].y - pointers[0].y);
                    if (this.initialDistance > 0) {
                        const scaleFactor = currentDistance / this.initialDistance;
                        const newScale = Math.max(1, Math.min(this.initialScale * scaleFactor, this.MAX_ZOOM_SCALE));
                        const deltaScale = newScale - this.scale;
                        const originX = (this.pinchCenterX - this.translateX) / this.scale;
                        const originY = (this.pinchCenterY - this.translateY) / this.scale;
                        this.translateX -= originX * deltaScale; this.translateY -= originY * deltaScale;
                        this.scale = newScale;
                        this.applyPanBoundaries(); this.updateZoom(false);
                    }
                } else if (this.isPanning && this.activePointers.size === 1) {
                    e.preventDefault();
                    const deltaX = e.clientX - this.touchStartX; const deltaY = e.clientY - this.touchStartY;
                    this.translateX = this.panStartX + deltaX; this.translateY = this.panStartY + deltaY;
                    this.applyPanBoundaries(); this.updateZoom(false);
                }
            }

                    handlePointerEnd(e) {
            if (!this.activePointers.has(e.pointerId) || !this.isInitialized) return;

            const pointerUpTime = Date.now();
            const pointerId = e.pointerId;
            const startPointerData = this.activePointers.get(pointerId); // Get start data

            try {
                 // Check if capture exists before releasing
                 if (e.target.hasPointerCapture && e.target.hasPointerCapture(pointerId)) {
                    e.target.releasePointerCapture(pointerId);
                 }
            } catch (err) {
                console.warn("Failed to release pointer:", err.message);
            }
            this.activePointers.delete(pointerId);

            const tapInterval = pointerUpTime - this.lastTapTime;
            let isDoubleTap = false;

            // --- Double Tap ---
             if (this.activePointers.size === 0 && e.pointerType !== 'mouse' &&
                 tapInterval < this.DOUBLE_TAP_TIMEOUT_MS && startPointerData && (pointerUpTime - startPointerData.startTime) < this.DOUBLE_TAP_TIMEOUT_MS
                  /* && tapInterval > this.MIN_TAP_DURATION_MS */ ) { // Check tap duration too

                isDoubleTap = true;
                const rect = this.viewerContainer.getBoundingClientRect();
                const tapX = e.clientX - rect.left;
                const tapY = e.clientY - rect.top;

                if (this.scale <= 1.1) {
                    const targetScale = this.DOUBLE_TAP_ZOOM_SCALE;
                    const containerCenterX = this.viewerContainer.clientWidth / 2;
                    const containerCenterY = this.viewerContainer.clientHeight / 2;
                    this.translateX = containerCenterX - (tapX * targetScale);
                    this.translateY = containerCenterY - (tapY * targetScale);
                    this.scale = targetScale;
                    console.log("Double tap zoom IN");
                } else {
                    this.resetZoom();
                    console.log("Double tap zoom OUT");
                }
                this.applyPanBoundaries();
                this.updateZoom(true);
            }
            // Update lastTapTime for the *next* double tap detection
            if (this.activePointers.size === 0) {
                this.lastTapTime = pointerUpTime;
            }


            // --- Swipe Detection (RTL Handled - Corrected based on user feedback) ---
            if (!isDoubleTap && !this.isZooming && this.scale <= 1.1 && this.activePointers.size === 0 && startPointerData) {
                const touchEndX = e.clientX;
                const touchEndY = e.clientY;
                const deltaX = touchEndX - this.touchStartX; // Use start position from pointerdown
                const deltaY = touchEndY - this.touchStartY;
                const swipeDuration = pointerUpTime - startPointerData.startTime;

                if (Math.abs(deltaX) > this.SWIPE_THRESHOLD_PX &&
                    Math.abs(deltaY) < this.SWIPE_VERTICAL_THRESHOLD_PX &&
                    swipeDuration < 500) { // Add duration limit

                    // Horizontal swipe detected
                    if (deltaX > 0) { // Swiped right (指を右に動かした)
                         console.log("Swipe Right detected");
                         if (this.readingDirection === 'rtl') {
                             this.nextPage(); // RTL: 右スワイプ -> 次のページ (index減)
                         } else {
                             this.prevPage(); // LTR: 右スワイプ -> 前のページ (index減)
                         }
                     } else { // Swiped left (指を左に動かした)
                          console.log("Swipe Left detected");
                         if (this.readingDirection === 'rtl') {
                             this.prevPage(); // RTL: 左スワイプ -> 前のページ (index増)
                         } else {
                             this.nextPage(); // LTR: 左スワイプ -> 次のページ (index増)
                         }
                     }
                     // Prevent swipe from also triggering click on nav zones if needed
                     // e.preventDefault(); // Use with caution
                }
            }


            // --- State Reset ---
            if (this.isZooming && this.activePointers.size < 2) {
                this.isZooming = false;
            }
            if (this.isPanning && this.activePointers.size === 0) {
                this.isPanning = false;
                this.viewerContainer.style.cursor = 'grab';
            }
            if (this.activePointers.size === 0) {
                if (this.scale < 1.05 && this.scale > 0.95 && !isDoubleTap) {
                    this.resetZoom();
                }
                if (this.viewerContainer.style.cursor === 'grabbing') {
                    this.viewerContainer.style.cursor = 'grab';
                }
                this.scheduleUiHide();
            }
        }

            // --- Zooming and Panning Logic ---
            updateZoom(useTransition = false) {
                this.zoomContainer.style.transition = useTransition ? 'transform 0.3s ease' : 'none';
                const clampedScale = Math.max(0.1, this.scale);
                // --- TEMPLATE LITERAL FIX ---
                this.zoomContainer.style.transform = `translate3d(${this.translateX}px, ${this.translateY}px, 0) scale(${clampedScale})`;
            }

            resetZoom() {
                if (this.scale !== 1 || this.translateX !== 0 || this.translateY !== 0) {
                    console.log("Resetting zoom and pan.");
                    this.scale = 1; this.translateX = 0; this.translateY = 0; this.isPanning = false;
                    this.viewerContainer.style.cursor = 'grab'; this.updateZoom(true);
                }
            }

            applyPanBoundaries() {
                const containerWidth = this.viewerContainer.clientWidth; const containerHeight = this.viewerContainer.clientHeight;
                if (!containerWidth || !containerHeight || this.scale <= 1) { this.translateX = 0; this.translateY = 0; return; }
                const contentWidth = containerWidth * this.scale; const contentHeight = containerHeight * this.scale;
                const maxTranslateX = Math.max(0, (contentWidth - containerWidth) / 2);
                const maxTranslateY = Math.max(0, (contentHeight - containerHeight) / 2);
                this.translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, this.translateX));
                this.translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, this.translateY));
            }

            // --- Keyboard (RTL Handled) ---
            handleKeyDown(e) {
                if (!this.isInitialized || this.isLoading) return;
                const activeElement = document.activeElement;
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.closest('#episode-list'))) {
                    if (e.key === 'Escape' && this.episodeOverlay.classList.contains('active')) { /* Handled below */ }
                    else { return; }
                }
                if (e.key === 'Escape' && this.episodeOverlay.classList.contains('active')) {
                    this.hideEpisodeList(); e.preventDefault(); this.episodeButton.focus(); return;
                }
                const prevAction = this.readingDirection === 'rtl' ? this.nextPage : this.prevPage;
                const nextAction = this.readingDirection === 'rtl' ? this.prevPage : this.nextPage;
                let pageChanged = false;
                switch (e.key) {
                    case 'ArrowLeft': case 'PageUp': e.preventDefault(); prevAction.call(this); pageChanged = true; break;
                    case 'ArrowRight': case ' ': case 'PageDown': e.preventDefault(); nextAction.call(this); pageChanged = true; break;
                    case 'Home': e.preventDefault(); if (this.currentPageIndex !== 0) { this.goToPage(0); pageChanged = true; } break;
                    case 'End': e.preventDefault(); const lastIndex = this.totalPages - 1; if (this.currentPageIndex !== lastIndex) { this.goToPage(lastIndex); pageChanged = true; } break;
                    case 'f': case 'F11': e.preventDefault(); this.toggleFullscreen(); break;
                    case 'Escape': if (this.isUIVisible) { this.hideUI(); e.preventDefault(); } break;
                }
                if (pageChanged) { this.showUI(); }
            }

            handleResize() {
                if (!this.isInitialized) return;
                console.log("Window resized");
                this.resetZoom();
                this.applyPanBoundaries();
                this.updateZoom(false);
            }
        } // End of MangaViewer Class

        // Initialize viewer once DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            if (!window.mangaViewerInstance) {
                console.log("DOM Ready, initializing MangaViewer...");
                window.mangaViewerInstance = new MangaViewer();
                window.mangaViewerInstance.init().catch(error => {
                    console.error("Viewer final initialization failed:", error);
                    const fallbackError = document.getElementById('init-error-fallback');
                    if (fallbackError && !fallbackError.textContent.includes('final initialization failed')) {
                        fallbackError.textContent += ' Final initialization failed. Please reload.';
                    }
                });
            } else {
                console.log("MangaViewer instance already exists.");
            }
        });
    </script>
</body>
</html>
